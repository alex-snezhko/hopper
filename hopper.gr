/**
 * @module Hopper: An HTTP microframework for the Grain programming language.
 * 
 * Version 0.1.0
 */

// this will likely get split into multiple files once Grain's module system becomes more advanced

import Option from "option"
import Result from "result"
import Number from "number"
import Map from "map"
import List from "list"
import Array from "array"
import String from "string"
import Char from "char"
import Regex from "regex"
import Int64 from "int64"
import Marshal from "marshal"
import Process from "sys/process"
import File from "sys/file"
import Time from "sys/time"

/**
 * @section Types: Type declarations included in the Hopper module.
 */

/**
 * Represents various HTTP request methods.
 */
export enum RequestMethod {
  Get,
  Post,
  Put,
  Delete,
  Head,
  Patch,
  Options,
  Trace,
  Method(String)
}

// TODO test with various percent encodings and whatnot

export enum OneOrMany {
  SingleVal(String),
  MultiVal(List<String>)
}

// /**
//  * Represents an incoming HTTP request.
//  */
// export record Request {
//   mut variables: Map.Map<String, String>,
//   _wagiEnv: Map.Map<String, String>,
//   method: RequestMethod,
//   params: Map.Map<String, String>,
//   query: Map.Map<String, QueryParam>,
//   fullUrl: String,
//   body: String,
// }

record RequestData {
  wagiEnv: Map.Map<String, String>,
  params: Map.Map<String, String>,
  query: Map.Map<String, OneOrMany>
}

/**
 * Represents HTTP response statuses.
 */
export enum Status {
  Continue,
  SwitchingProtocols,

  HttpOk,
  Created,
  Accepted,
  NonAuthoritativeInformation,
  NoContent,
  ResetContent,
  ParialContent,

  MultipleChoices,
  MovedPermanently,
  Found,
  SeeOther,
  NotModified,
  TemporaryRedirect,
  PermanentRedirect,

  BadRequest,
  Unauthorized,
  PaymentRequired,
  Forbidden,
  NotFound,
  MethodNotAllowed,
  NotAcceptable,
  ProxyAuthenticationRequired,
  RequestTimeout,
  Conflict,
  Gone,
  LengthRequired,
  PreconditionFailed,
  PayloadTooLarge,
  UriTooLong,
  UnsupportedMediaType,
  RangeNotSatisfiable,
  ExpectationFailed,
  ImATeapot,
  MisdirectedRequest,
  TooEarly,
  UpgradeRequired,
  PrecoditionRequired,
  TooManyRequests,
  RequestHeaderFieldsTooLarge,
  UnavailableForLegalReasons,

  InternalServerError,
  NotImplemented,
  BadGateway,
  ServiceUnavailable,
  GatewayTimeout,
  HttpVersionNotSupported,
  VariantAlsoNegotiates,
  NotExtended,
  NetworkAuthenticationRequired,

  HttpStatus(Number)
}

// /**
//  * Represents an HTTP response.
//  */
// export record Response {
//   status: Status,
//   headers: Map.Map<String, String>,
//   body: String,
// }

record ResponseData {
  status: Status
}

record Message<a> {
  message: a,
  headers: Map.Map<String, String>,
  body: String,
  variables: Map.Map<String, Bytes>,
}

export type Request = Message<RequestData>
export type Response = Message<ResponseData>

/**
 * Represents an HTTP request handler which processes a request and returns a response.
 */
export type RequestHandler = Request -> Response

/**
 * Represents an HTTP middleware, which sits between the client and base request handler.
 */
export type Middleware = RequestHandler -> RequestHandler

enum RequestMethods {
  Methods(List<RequestMethod>),
  All
}

record Route {
  path: String,
  routeHandler: RouteHandler,
},
enum RouteHandler {
  Endpoint(RequestMethods, RequestHandler),
  Router(Middleware, List<Route>)
}

/**
 * @section Values: Functions included in the Hopper module.
 */

/**
 * Writes a message to the WAGI log file.
 * 
 * @param val: The value to write out to the log
 */
export let log = val => {
  ignore(File.fdWrite(File.stderr, toString(val) ++ "\n"))
}

/**
 * Converts a string to an HTTP `RequestMethod`.
 * 
 * @param str: The string to convert to a `RequestMethod`
 * @returns A `RequestMethod` representing the string
 * 
 * @example Hopper.stringToMethod("GET") // RequestMethod.Get
 */
export let stringToMethod = str => {
  match (str) {
    "GET" => Get,
    "POST" => Post,
    "PUT" => Put,
    "DELETE" => Delete,
    "HEAD" => Head,
    "PATCH" => Patch,
    "OPTIONS" => Options,
    "TRACE" => Trace,
    _ => Method(str)
  }
}

/**
 * Converts a `RequestMethod` to a string describing the method.
 * 
 * @param method: `RequestMethod` to stringify
 * @returns A string representing the `RequestMethod`
 */
export let methodToString = method => {
  match (method) {
    Get => "GET",
    Post => "POST",
    Put => "PUT",
    Delete => "DELETE",
    Head => "HEAD",
    Patch => "PATCH",
    Options => "OPTIONS",
    Trace => "TRACE",
    Method(str) => str,
  }
}

/**
 * Converts a response status to its corresponding status code.
 * 
 * @param status: An `HttpStatus` to get the status code of
 * @returns A status code for the response status
 */
export let statusCode = status => {
  match (status) {
    Continue => 100,
    SwitchingProtocols => 101,

    HttpOk => 200,
    Created => 201,
    Accepted => 202,
    NonAuthoritativeInformation => 203,
    NoContent => 204,
    ResetContent => 205,
    ParialContent => 206,

    MultipleChoices => 300,
    MovedPermanently => 301,
    Found => 302,
    SeeOther => 303,
    NotModified => 304,
    TemporaryRedirect => 307,
    PermanentRedirect => 308,

    BadRequest => 400,
    Unauthorized => 401,
    PaymentRequired => 402,
    Forbidden => 403,
    NotFound => 404,
    MethodNotAllowed => 405,
    NotAcceptable => 406,
    ProxyAuthenticationRequired => 407,
    RequestTimeout => 408,
    Conflict => 409,
    Gone => 410,
    LengthRequired => 411,
    PreconditionFailed => 412,
    PayloadTooLarge => 413,
    UriTooLong => 414,
    UnsupportedMediaType => 415,
    RangeNotSatisfiable => 416,
    ExpectationFailed => 417,
    ImATeapot => 418,
    MisdirectedRequest => 421,
    TooEarly => 425,
    UpgradeRequired => 426,
    PrecoditionRequired => 428,
    TooManyRequests => 429,
    RequestHeaderFieldsTooLarge => 431,
    UnavailableForLegalReasons => 451,

    InternalServerError => 500,
    NotImplemented => 501,
    BadGateway => 502,
    ServiceUnavailable => 503,
    GatewayTimeout => 504,
    HttpVersionNotSupported => 505,
    VariantAlsoNegotiates => 506,
    NotExtended => 510,
    NetworkAuthenticationRequired => 511,
    
    HttpStatus(status) => status
  }
}

let isStatusType = beginRange => status => {
  let code = statusCode(status)
  let endRange = beginRange + 100
  code >= beginRange && code < endRange
}

export let isInformational = isStatusType(100)
export let isSuccessful = isStatusType(200)
export let isRedirection = isStatusType(300)
export let isClientError = isStatusType(400)
export let isServerError = isStatusType(500)

// credit to https://github.com/deislabs/wagi-fileserver for the media types
let mediaTypes = Map.fromList([
  // Text formats
  ("txt", "text/plain"),
  ("md", "text/plain"),
  ("mdown", "text/plain"),
  ("htm", "text/html"),
  ("html", "text/html"),
  ("xhtml", "application/xhtml+xml"),
  ("xml", "application/xml"),
  ("css", "text/css"),
  ("ics", "text/calendar"),

  // Serialization formats
  ("json", "application/json"),
  ("jsonld", "application/ld+json"),
  ("toml", "application/toml"),
  ("yaml", "application/yaml"),

  // Applications
  // According to MSDN, prefered is text/javascript
  ("js", "text/javascript"),
  ("mjs", "text/javascript"),
  ("wasm", "application/wasm"),
  ("csv", "text/csv"),
  ("sh", "application/x-sh"),

  // Images
  ("apng", "image/apng"),
  ("avif", "image/avif"),
  ("png", "image/png"),
  ("png", "image/png"),
  ("jpg", "image/jpeg"),
  ("jpeg", "image/jpeg"),
  ("pjpeg", "image/jpeg"),
  ("pjp", "image/jpeg"),
  ("jfif", "image/jpeg"),
  ("gif", "image/gif"),
  ("tif", "image/tiff"),
  ("tiff", "image/tiff"),
  ("webp", "image/webp"),
  ("svg", "image/svg+xml"),
  ("bmp", "image/bmp"),
  ("ico", "image/vnd.microsoft.icon"),

  // Audio/Video
  ("aac", "audio/aac"),
  ("avi", "video/x-msvideo"),
  ("wav", "audio/wave"),
  ("webm", "video/webm"),
  ("mp3", "audio/mpeg"),
  ("mp4", "video/mp4"),
  ("mpeg", "video/mpeg"),
  ("oga", "audio/ogg"),
  ("ogv", "video/ogg"),
  ("ogx", "application/ogg"),
  ("ts", "video/mp2t"),

  // Compressed
  ("bz2", "application/x-bzip2"),
  ("tbz", "application/x-bzip2"),
  ("tbz2", "application/x-bzip2"),
  ("gz", "application/gzip"),
  ("rar", "application/vnd.rar"),
  ("tar", "text/x-tar"),
  ("tgz", "application/gzip"),
  ("jar", "application/java-archive"),
  ("mpkg", "application/vnd.apple.installer+xml"),
  ("zip", "application/zip"),
  ("7z", "application/x-7z-compressed"),

  // Binary
  ("azw", "application/vnd.amazon.ebook"),
  ("bin", "application/octet-stream"),
  ("doc", "application/msword"),
  (
    "docx",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  ),
  ("epub", "application/epub+zip"),
  ("odp", "application/vnd.oasis.opendocument.presentation"),
  ("ods", "application/vnd.oasis.opendocument.spreadsheet"),
  ("odt", "application/vnd.oasis.opendocument.text"),
  ("pdf", "application/pdf"),
  ("ppt", "application/vnd.ms-powerpoint"),
  (
    "pptx",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  ),
  ("rtf", "application/rtf"),
  ("vsd", "application/vnd.visio"),
  ("xls", "application/vnd.ms-excel"),
  (
    "xlsx",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  ),

  // Fonts
  ("eot", "application/vnd.ms-fontobject"),
  ("otf", "font/otf"),
  ("ttf", "font/ttf"),
  ("woff", "font/woff"),
  ("woff2", "font/woff2"),
])

/**
 * Guesses the MIME type of a media file by its filename extension.
 * 
 * @param fileName: The filename to guess the MIME type of
 * @returns A MIME type string for the filename
 */
export let guessMimeType = fileName => {
  match (String.lastIndexOf(".", fileName)) {
    Some(i) => {
      let extension = String.slice(i + 1, String.length(fileName), fileName)
      Option.unwrapWithDefault("application/octet-stream", Map.get(extension, mediaTypes))
    },
    None => "application/octet-stream",
  }
}

export let middlewares: List<Middleware> -> Middleware = mws => handler => {
  List.reduceRight((mw, handler) => mw(handler), handler, mws)
}
// TODO add middlewares: authentication, logging, etc
// TODO look into CGI section 3.1, 4.1.1 to determine how auth could be done

// TODO add cookies
// TODO implement all suggestions in https://datatracker.ietf.org/doc/html/rfc3875

/**
 * Creates a new `Response` with a status, headers, and body.
 * 
 * @param status: The desired HTTP status
 * @param headers: The desired HTTP headers
 * @param body: The body string to create the `Response` with
 * @returns A new `Response` with the given values
 */
export let response = (status, headers, body) => {
  { message: { status, }, variables: Map.make(), headers, body }: Response
}

/**
 * Creates a new `Response` from an existing response, but with the response status code changed.
 * 
 * @param status: The desired HTTP status
 * @param res: The base response
 * @returns A new `Response` with the desired HTTP status
 */
export let status = (status: Status, res: Response) => {
  let { headers, body, _ } = res
  response(status, headers, body)
}

/**
 * Creates a new OK `Response` with a text body and `"text/plain"` Content-Type.
 * 
 * @param body: The text body to create the `Response` with
 * @returns A new text `Response`
 */
export let text = body => response(HttpOk, Map.fromList([("Content-Type", "text/plain")]), body)

/**
 * Creates a new OK `Response` with a JSON string body and `"application/json"` Content-Type.
 * 
 * Note: the argument type will likely be changed to a more friendly JSON
 * representation once https://github.com/grain-lang/grain/pull/1133 gets
 * merged.
 * 
 * @param body: The JSON body to create the `Response` with
 * @returns A new JSON `Response`
 */
export let json = body => response(HttpOk, Map.fromList([("Content-Type", "application/json")]), body)

/**
 * Creates a new OK `Response` with the specified content type.
 * 
 * @param contentType: The Content-Type to set for the `Response`
 * @param body: The body of the response
 * @returns A new `Response` with the given content type
 */
export let contentType = (contentType, body) => response(HttpOk, Map.fromList([("Content-Type", contentType)]), body)

let notFound = response(NotFound, Map.fromList([("Content-Type", "text/plain")]), "Route not found")
let methodNotSupported = supportedMethods => {
  let allowed = List.join(", ", List.map(methodToString, supportedMethods))
  response(
    MethodNotAllowed,
    Map.fromList([("Content-Type", "text/plain"), ("Allow", allowed)]),
    "Method not allowed for this route; allowed methods are " ++ allowed
  )
}

/**
 * Creates a new `Response` from a static file on the server at the given path.
 * 
 * @param filePath: The path of the file to search for on the server
 * @returns A new OK `Response` if the file is found, or a "Not Found" reponse otherwise
 */
export let file = filePath => {
  let result = File.pathOpen(File.pwdfd, [], filePath, [], [File.FdFilestats, File.FdRead], [], [])

  match (result) {
    Err(_) => response(NotFound, Map.fromList([("Content-Type", "text/plain")]), "404 File Not Found"),
    Ok(fd) => {
      let stats = Result.unwrap(File.fdFilestats(fd))
      let (contents, _) = Result.unwrap(File.fdRead(fd, Int64.toNumber(stats.size)))
      File.fdClose(fd)

      response(HttpOk, Map.fromList([("Content-Type", guessMimeType(filePath))]), contents)
    }
  }
}

/**
 * Creates a new redirection `Response` to another route on the server.
 * 
 * @param path: The local path to redirect to
 * @param req: The incoming `Request`
 * @returns A new redirection `Response` with status code "302 Found"
 */
export let redirectLocal = (path, req: Request) => {
  let item = key => Option.unwrap(Map.get(key, req.message.wagiEnv))
  let protocol = if (String.startsWith("https://", item("X_FULL_URL"))) "https://" else "http://"
  let baseUrl = protocol ++ item("SERVER_NAME") ++ ":" ++ item("SERVER_PORT")
  response(Found, Map.fromList([("Location", baseUrl ++ path)]), "")
}

/**
 * Creates a new redirection `Response` to an arbitrary URL.
 * 
 * @param url: The URL to redirect to
 * @returns A new redirection `Response` with status code "302 Found"
 */
export let redirectExternal = url => response(Found, Map.fromList([("Location", url)]), "")

let createRoute = (path, methods, handler) => {
  { path, routeHandler: Endpoint(methods, handler) }
}

/**
 * Creates a new `Route` for handling GET requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling GET requests at a path
 */
export let get = (path, handler) => {
  createRoute(path, Methods([Get]), handler)
}

/**
 * Creates a new `Route` for handling POST requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling POST requests at a path
 */
export let post = (path, handler) => {
  createRoute(path, Methods([Post]), handler)
}

/**
 * Creates a new `Route` for handling PUT requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling PUT requests at a path
 */
export let put = (path, handler) => {
  createRoute(path, Methods([Put]), handler)
}

/**
 * Creates a new `Route` for handling DELETE requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling DELETE requests at a path
 */
export let delete = (path, handler) => {
  createRoute(path, Methods([Delete]), handler)
}

/**
 * Creates a new `Route` for handling HEAD requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling HEAD requests at a path
 */
export let head = (path, handler) => {
  createRoute(path, Methods([Head]), handler)
}

/**
 * Creates a new `Route` for handling PATCH requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling PATCH requests at a path
 */
export let patch = (path, handler) => {
  createRoute(path, Methods([Patch]), handler)
}

/**
 * Creates a new `Route` for handling OPTIONS requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling OPTIONS requests at a path
 */
export let options = (path, handler) => {
  createRoute(path, Methods([Options]), handler)
}

/**
 * Creates a new `Route` for handling TRACE requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling TRACE requests at a path
 */
export let trace = (path, handler) => {
  createRoute(path, Methods([Trace]), handler)
}

/**
 * Creates a new `Route` for handling requests at a path.
 * 
 * @param method: The HTTP method the route will handle
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling requests at a path
 */
export let route = (method, path, handler) => {
  createRoute(path, Methods([method]), handler)
}

/**
 * Creates a new `Route` for handling requests at a path with multiple allowed HTTP methods.
 * 
 * @param methods: The HTTP methods the route will handle
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling requests at a path
 */
export let methodsRoute = (methods, path, handler) => {
  createRoute(path, Methods(methods), handler)
}

/**
 * Creates a new `Route` for handling requests at a path for all HTTP methods.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling requests at a path
 */
export let all = (path, handler) => {
  createRoute(path, All, handler)
}

/**
 * Creates a new `Route` composed of multiple sub-routes defined relative to
 * the path given. A middleware is also applied to all requests in the scope.
 * 
 * @param path: The relative path the request handler will reside on
 * @param middleware: The middleware to apply to the routes in the scope
 * @param routes: The `Route`s composing the scope
 * @returns A new `Route` handling requests rooted from the path
 */
export let scopeWithMiddleware = (path, middleware, routes) => {
  { path, routeHandler: Router(middleware, routes) }
}

// TODO integrate testing
/**
 * Creates a new `Route` composed of multiple sub-routes defined relative to the path given.
 * 
 * @param path: The relative path the request handler will reside on
 * @param routes: The `Route`s composing the scope
 * @returns A new `Route` handling requests rooted from the path
 */
export let scope = (path, routes) => {
  scopeWithMiddleware(path, identity, routes)
}

let genericErrMsg = "make sure you are running in a properly configured WAGI environment"
let failWithMsg = msg => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg
let failWithMsgWithErr = (msg, err) => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg ++ "; err " ++ toString(err)

let outputResponse = (res: Response) => {
  let { headers, body, message: { status }, _ } = res
  // script must specify Content-Type per CGI v1.1 spec, so default to
  // application/octet-stream if one was not given
  Map.update("Content-Type", val => match (val) {
    None => Some("application/octet-stream"),
    _ => val
  }, headers)
  Map.set("Status", toString(statusCode(status)), headers)

  let safeHeaders = Map.fromList(List.map(((key, val)) => {
    // remove any newline characters from headers because that will cause
    // header values to be written to body (since a blank line separates
    // headers from body in CGI spec)
    let makeSafe = str => Array.reduce(
      (str, c) => str ++ (if (c == '\n') "\\n" else Char.toString(c)),
      "",
      String.explode(str)
    )
    (makeSafe(key), makeSafe(val))
  }, Map.toList(headers)))

  // redirects should not specify additional headers per CGI spec
  match (Map.get("Location", safeHeaders)) {
    Some(location) => print("Location: " ++ location ++ "\n\n"),
    None => {
      Map.forEach((key, val) => print(key ++ ": " ++ val), safeHeaders)
      // empty line separates headers from body per CGI spec
      print("")
      print(body)
    }
  }
}

let getWagiEnv = () => {
  let vars = match (Process.env()) {
    Ok(vars) => vars,
    Err(err) => failWithMsgWithErr("Unable to read system environment variables", err)
  }

  Map.fromArray(Array.map(var => {
    match (String.indexOf("=", var)) {
      Some(i) => {
        let varName = String.slice(0, i, var)
        let varVal = String.slice(i + 1, String.length(var), var)
        (varName, varVal)
      },
      None => failWithMsg("Error processing environment variable " ++ var)
    }
  }, vars))
}

let getHeaders = wagiEnv => {
  let headerEntries = List.filter(((key, _)) => String.startsWith("HTTP_", key), Map.toList(wagiEnv))
  let headerKeyVals = List.map(((key, val)) => {
    let key = String.slice(5, String.length(key), key)
    (key, val)
  }, headerEntries)
  Map.fromList(headerKeyVals)
}

let getReqMethod = wagiEnv => {
  match (Map.get("REQUEST_METHOD", wagiEnv)) {
    Some(reqMethod) => stringToMethod(reqMethod),
    _ => failWithMsg("Did not find \"REQUEST_METHOD\" in request")
  }
}

let toLower = str => {
  String.implode(Array.map(c => {
    let code = Char.code(c)
    if (code >= 65 && code <= 90) Char.fromCode(code + 32) else c
  }, String.explode(str)))
}

let headerNormed = str => {
  String.implode(Array.map(
    c => if (c == '-') '_' else c,
    String.explode(toLower(str))
  ))
}

/**
 * Fetches a URL query parameter with the given name.
 * 
 * @param key: The name of the parameter to fetch the value of
 * @param req: The request to fetch the query parameter from
 * @returns The value of the query parameter with the given name
 */
export let query = (key, req: Request) => {
  Map.get(key, req.message.query)
}

// TODO maybe change this to just mapping SingleVal/MultiVal
/**
 * Fetches a URL query parameter with the given name.
 * 
 * @param key: The name of the parameter to fetch the value of
 * @param req: The request to fetch the query parameter from
 * @returns The value of the query parameter with the given name
 */
export let joinedQuery = (key, delim, req: Request) => {
  Option.map(val => match (val) {
    SingleVal(val) => val,
    MultiVal(vals) => List.join(delim, vals)
  }, Map.get(key, req.message.query))
}

let getPath = wagiEnv => {
  match (Map.get("PATH_INFO", wagiEnv)) {
    Some(val) => val,
    None => failWithMsg("Did not find \"PATH_INFO\" in environment")
  }
}

/**
 * Fetches the full path from the requested URL.
 * 
 * @param req: The request to examine
 * @returns The full path requested
 */
export let path = (req: Request) => {
  getPath(req.message.wagiEnv)
}

/**
 * Fetches a path parameter from the request.
 * 
 * @param key: The path parameter to fetch
 * @param req: The request to examine
 * @returns The path parameter requested
 */
export let param = (key, req: Request) => {
  Option.expect("URL path param " ++ key ++ " expected to exist on request but did not", Map.get(key, req.message.params))
}

/**
 * Fetches the HTTP method of the request.
 * 
 * @param req: The request to examine
 * @returns The HTTP method of the request.
 */
export let method = (req: Request) => {
  getReqMethod(req.message.wagiEnv)
}

/**
 * Fetches a header from the message.
 * 
 * @param key: The header to request
 * @param msg: The request or response to examine
 * @returns The header value requested
 */
export let header = (key, msg) => {
  let key = headerNormed(key)
  let header = List.find(
    ((headerKey, val)) => headerNormed(headerKey) == key,
    Map.toList(msg.headers)
  )
  match (header) {
    Some((_, val)) => Some(val),
    None => None
  }
}

/**
 * Fetches the message body as a string.
 * 
 * @param msg: The request or response to examine
 * @returns The body as a string
 */
export let bodyString = msg => {
  msg.body
}

/**
 * Sets a variable on a message to a new arbitrary value.
 * 
 * @param key: The variable to set
 * @param value: The new value to give the variable
 * @param msg: The message to attach the variable to
 */
export let setVariable = (key, value, msg) => {
  Map.set(key, Marshal.marshal(value), msg.variables)
}

/**
 * Represents possible `Err` reasons for why a variable's value was not read.
 * 
 * `NotSet` indicates that a variable with the given name does not exist
 * 
 * `DeserializationError` indicates that the variable was unable to be
 * deserialized properly. The attached `String` gives the error reason
 */
export enum GetVariableError {
  NotSet,
  DeserializationError(String),
}

/**
 * Fetches the value of a variable set on a message. The result of this
 * function should be explicitly typed.
 * 
 * @param key: The variable to fetch
 * @param msg: The message to inspect
 * @returns The value of the variable requested
 */
export let variable = (key, msg) => {
  match (Map.get(key, msg.variables)) {
    Some(val) => {
      match (Marshal.unmarshal(val)) {
        Ok(val) => Ok(val),
        Err(err) => Err(DeserializationError(err)),
      }
    },
    None => Err(NotSet)
  }
}

// export let withLogging: Middleware = next => req => {
//   let begin = Time.monotonicTime()
//   next(req)
//   let end = Time.monotonicTime()
//   log(methodToString(req.method) ++ " " ++ req.fullUrl ++ " ")
// }

// TODO finish
export let withCors = next => req => {
  let res = next(req)
  // handle CORS "preflight" request
  if (res == notFound && method(req) == Options) {
    response(
      NoContent,
      Map.fromList([
        ("Access-Control-Allow-Methods", "GET,HEAD,PUT,PATCH,POST,DELETE"),
        ("Access-Control-Allow-Origin", "*"),
        ("Access-Control-Allow-Headers", "*")
      ]),
      ""
    )
  } else {
    res
  }
}

let parseUrlEncoded = parts => {
  let valMap = Map.make()
  List.forEach(part => {
    let (name, val) = match (String.indexOf("=", part)) {
      // some parts may only have a key, set value to empty string in this case
      None => (part, ""),
      Some(i) => {
        let name = String.slice(0, i, part)
        let val = String.slice(i + 1, String.length(part), part)
        (name, val)
      }
    }
    match (Map.get(name, valMap)) {
      None => Map.set(name, SingleVal(val), valMap),
      Some(SingleVal(currVal)) => Map.set(name, MultiVal([currVal, val]), valMap),
      Some(MultiVal(currVals)) => Map.set(name, MultiVal(List.append(currVals, [val])), valMap)
    }
  }, parts)
  valMap
}

// TODO handle semicolons in headers such as Content-Type: <type>; charset=utf-8
/**
 * Parses an HTTP request with form data into a `Map` mapping form item names
 * to their values. The keys/values are expected to be in the URL query string
 * on GET requests and in the body (along with a `Content-Type: x-www-form-urlencoded`
 * header) on other requests.
 * 
 * @param req: The incoming `Request`
 * @returns A `Map` mapping form item names to their values
 */
export let parseForm = req => {
  match (method(req)) {
    Get => Ok(req.message.query),
    _ => {
      if (header("Content-Type", req) == Some("application/x-www-form-urlencoded")) {
        let parts = Array.toList(String.split("&", req.body))
        Ok(parseUrlEncoded(parts))
      } else {
        Err(response(UnsupportedMediaType, Map.fromList([("Content-Type", "text/plain")]), "Expected Content-Type: application/x-www-form-urlencoded"))
      }
    }
  }
}

// let parseContentDispositionHeader = headers => {
//   let contentDispositionLine = List.find(
//     line => String.startsWith("content-disposition", toLower(line)),
//     headers
//   )
//   match (contentDispositionLine) {
//     None => None,
//     Some(contentDispositionLine) => {
//       let regex = Result.unwrap(Regex.make("content-disposition:\\s*form-data;\\s*name=\"(.+)\""))
//       match (Regex.find(regex, toLower(contentDispositionLine))) {
//         None => None,
//         Some(reMatch) => {
//           let (nameBeginI, nameEndI) = reMatch.groupPosition(1)
//           let name = String.slice(nameBeginI, nameEndI, contentDispositionLine)
//           Some(name)
//         }
//       }

//     }
//   }
// }

// let readMultipart = (body, boundary) => {
//   let lines = Array.toList(String.split("\n", body))
//   let lines = List.takeWhile(line => line != "--" ++ boundary ++ "--", lines)
//   let parts = List.reduceRight(
//     (line, parts) => {
//       if (line == "--" ++ boundary) {
//         let [partLines, ...rest] = parts
//         [[line, ...partLines], rest]
//       } else {
//         [[], parts]
//       }
//     },
//     [[]],
//     lines
//   )
//   List.reduce(
//     partLines => {
//       let lineEmpty = line => String.strip(line) == ""

//       let headers = List.takeWhile(line => !lineEmpty(line), partLines)
//       let body = List.dropWhile(lineEmpty, List.dropWhile(line => !lineEmpty(line), partLines))

//       let itemName = parseContentDispositionHeader(headers)
//       let bodyStr = String.join("\n", body)
//     },
//     parts
//   )
// }

// export let parseMultipartForm = req => {
//   match (req.method) {
//     Post => match (header("Content-Type", req)) {
//       Some(val) when String.startsWith("multipart/form-data;", val) => {
//         let boundary = String.trim(String.slice(String.length("multipart/form-data;"), String.length(val), val))
//         if (String.startsWith("boundary=", boundary)) {
//           // TODO consider quotes
//           let boundaryVal = String.slice(String.length("boundary="), String.length(boundary), val)
//           readMultipart(req.body, boundaryVal)
//         } else {
//           Map.make()
//         }
//       },
//       _ => Map.make()
//     },
//     _ => Map.make(),
//   }
// }

// TODO json deserialization
let getBody = wagiEnv => {
  let bodyLengthStr = match (Map.get("CONTENT_LENGTH", wagiEnv)) {
    Some(val) => val,
    None => failWithMsg("Did not find \"CONTENT_LENGTH\" in environment")
  }

  let bodyLength = match (Number.parseInt(bodyLengthStr, 10)) {
    Ok(num) => num,
    Err(err) => failWithMsgWithErr("Failed to parse \"CONTENT_LENGTH\" from environment to an integer", err)
  }

  match (File.fdRead(File.stdin, bodyLength)) {
    Ok((body, _)) => body,
    Err(err) => failWithMsgWithErr("Failed to read request body", err)
  }
}

let getQueryMap = () => {
  match (Process.argv()) {
    Ok(args) => {
      let [_, ...queryParamList] = Array.toList(args)
      parseUrlEncoded(queryParamList)
    },
    Err(err) => failWithMsgWithErr("Unable to read system arguments", err)
  }
}
    
// TODO maybe normalize urls or something to make more robust; also currently trailing slash does not work if in URL
// TODO remove //, /../, /./ when reading files
let matchRestRegex = Result.unwrap(Regex.make("/\\*$"))
// a bit of a hack to not capture regex groups specified in route.
// if something is going wrong with matching patterns it may be due to this
let captureGroupRegex = Result.unwrap(Regex.make("(?<!\\\\)\\("))
let replaceWithCapturesRegex = Result.unwrap(Regex.make("<\\w+\\(\\?:(.*)\\)>"))
let paramRegex = Result.unwrap(Regex.make("<\\w+>"))
let customParamRegex = Result.unwrap(Regex.make("<\\w+\\((.*)\\)>"))
let paramNameRegex = Result.unwrap(Regex.make("<(\\w+)>"))
let customParamNameRegex = Result.unwrap(Regex.make("<(\\w+)\\(.*\\)>"))
let slashAtEndRegex = Result.unwrap(Regex.make("/$"))
let noDollarSignAtEnd = Result.unwrap(Regex.make("(?<!\\$)$"))

let preprocessRouteRegex = route => {
  let routeRegex = List.reduce(
    (str, (regex, replaceWith)) => {
      // log("rr " ++ str)
      Regex.replaceAll(regex, str, replaceWith)
    },
    route,
    [
      (matchRestRegex, "/.*"),
      (matchRestRegex, "/.*"),
      (captureGroupRegex, "(?:"),
      (replaceWithCapturesRegex, "($1)"),
      (customParamRegex, "($1)"),
      (paramRegex, "(\\w+)"),
      (slashAtEndRegex, ""),
      (noDollarSignAtEnd, "$"),
    ]
  )

  match (Regex.make(routeRegex)) {
    Err(_) => failWithMsg("Invalid route path " ++ route),
    Ok(routeRegex) => routeRegex
  }
}

let findReqHandler = (reqMethod, path, route) => {
  let pathVars = Map.make()
  let notFoundHandler = req => notFound

  let rec findReqHandlerHelper = (pathSegment, route) => {
    let paramNames = List.map(
      (matchRes: Regex.MatchResult) => Option.unwrap(matchRes.group(1)),
      List.append(
        Regex.findAll(paramNameRegex, route.path),
        Regex.findAll(customParamNameRegex, route.path)
      )
    )

    let routeRegex = preprocessRouteRegex(route.path)
    let pathMatch = Regex.find(routeRegex, pathSegment)
    match (pathMatch) {
      None => notFoundHandler,
      Some(pathMatch) => {
        let (thisPathStartI, thisPathEndI) = Option.unwrap(pathMatch.groupPosition(0))
        if (thisPathStartI != 0) {
          notFoundHandler
        } else {
          let matchedSegment = Option.unwrap(pathMatch.group(0))
          if (pathMatch.numGroups > 1) {
            let [_, ...paramVals] = Array.toList(Array.map(grp => Option.unwrap(grp), pathMatch.allGroups()))
            List.forEach(((paramName, paramVal)) => {
              Map.set(paramName, paramVal, pathVars)
            }, List.zip(paramNames, paramVals))
          }
          let reqHandler = match (route.routeHandler) {
            Endpoint(handlerMethods, reqHandler) => {
              // if there is more left to the path e.g. if the route matcher is
              // /hi but the URL hit is /hi/hello, then consider it not matched
              if (thisPathEndI != String.length(pathSegment)) {
                notFoundHandler
              } else {
                match (handlerMethods) {
                  All => reqHandler,
                  Methods(methods) => {
                    if (List.contains(reqMethod, methods)) {
                      reqHandler
                    } else {
                      req => methodNotSupported(methods)
                    }
                  },
                }
              }
            },
            Router(middleware, routeHandlers) => {
              let nextPathSegment = String.slice(thisPathEndI, String.length(pathSegment), pathSegment)
              let nextPathSegment = if (!String.startsWith("/", nextPathSegment)) "/" ++ nextPathSegment else nextPathSegment
              // TODO may require changes here
              let reqHandler = List.reduce(
                (found, routeHandler) => {
                  if (found == notFoundHandler) {
                    findReqHandlerHelper(nextPathSegment, routeHandler)
                  } else {
                    found
                  }
                },
                notFoundHandler,
                routeHandlers
              )
              middleware(reqHandler)
            }
          }
          reqHandler
        }
      }
    }
  }

  (findReqHandlerHelper(path, route), pathVars)
}

/**
 * Entry point for creating a server, taking a list of routes and a middleware
 * to apply to all routes.
 * 
 * @param middleware: The middleware to use globally for the server
 * @param routes: The root routes for the server
 */
export let serveWithMiddleware = (middleware, routes) => {
  let wagiEnv = getWagiEnv()

  let rootRoute = { path: "/", routeHandler: Router(middleware, routes) }
  let (reqHandler, params) = findReqHandler(getReqMethod(wagiEnv), getPath(wagiEnv), rootRoute)
  let request = {
    message: {
      wagiEnv,
      params,
      query: getQueryMap()
    },
    variables: Map.make(),
    headers: getHeaders(wagiEnv),
    body: getBody(wagiEnv)
  }
  let response = reqHandler(request)
  outputResponse(response)
}

/**
 * Entry point for creating a server, taking a list of route handlers.
 * 
 * @param routes: The root routes for the server
 */
export let serve = routes => {
  serveWithMiddleware(identity, routes)
}
