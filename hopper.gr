/**
 * @module Hopper: An HTTP microframework for the Grain programming language.
 * 
 * Version 0.1.0
 */

import Option from "option"
import Result from "result"
import Number from "number"
import Map from "map"
import List from "list"
import Array from "array"
import String from "string"
import Char from "char"
import Regex from "regex"
import Int64 from "int64"
import Marshal from "marshal"
import Process from "sys/process"
import File from "sys/file"
import Time from "sys/time"

/**
 * @section Types: Type declarations included in the Hopper module.
 */

/**
 * Represents various HTTP request methods.
 */
export enum RequestMethod {
  Get,
  Post,
  Put,
  Delete,
  Head,
  Patch,
  Connect,
  Options,
  Trace,
  Method(String)
}

// TODO test with various percent encodings and whatnot

export enum QueryParam {
  SingleVal(String),
  MultiVal(List<String>)
}

// /**
//  * Represents an incoming HTTP request.
//  */
// export record Request {
//   mut variables: Map.Map<String, String>,
//   _wagiEnv: Map.Map<String, String>,
//   method: RequestMethod,
//   params: Map.Map<String, String>,
//   query: Map.Map<String, QueryParam>,
//   fullUrl: String,
//   body: String,
// }

record RequestData {
  wagiEnv: Map.Map<String, String>,
  params: Map.Map<String, String>,
  query: Map.Map<String, QueryParam>
}

/**
 * Represents HTTP response statuses.
 */
export enum Status {
  Continue,
  SwitchingProtocols,

  HttpOk,
  Created,
  Accepted,
  NonAuthoritativeInformation,
  NoContent,
  ResetContent,
  ParialContent,

  MultipleChoices,
  MovedPermanently,
  Found,
  SeeOther,
  NotModified,
  TemporaryRedirect,
  PermanentRedirect,

  BadRequest,
  Unauthorized,
  PaymentRequired,
  Forbidden,
  NotFound,
  MethodNotAllowed,
  NotAcceptable,
  ProxyAuthenticationRequired,
  RequestTimeout,
  Conflict,
  Gone,
  LengthRequired,
  PreconditionFailed,
  PayloadTooLarge,
  UriTooLong,
  UnsupportedMediaType,
  RangeNotSatisfiable,
  ExpectationFailed,
  ImATeapot,
  MisdirectedRequest,
  TooEarly,
  UpgradeRequired,
  PrecoditionRequired,
  TooManyRequests,
  RequestHeaderFieldsTooLarge,
  UnavailableForLegalReasons,

  InternalServerError,
  NotImplemented,
  BadGateway,
  ServiceUnavailable,
  GatewayTimeout,
  HttpVersionNotSupported,
  VariantAlsoNegotiates,
  NotExtended,
  NetworkAuthenticationRequired,

  HttpStatus(Number)
}

// /**
//  * Represents an HTTP response.
//  */
// export record Response {
//   status: Status,
//   headers: Map.Map<String, String>,
//   body: String,
// }

record ResponseData {
  status: Status
}

record Message<a> {
  message: a,
  headers: Map.Map<String, String>,
  body: String,
  variables: Map.Map<String, Bytes>,
}

export type Request = Message<RequestData>
export type Response = Message<ResponseData>

/**
 * Represents an HTTP request handler which processes a request and returns a response.
 */
export type RequestHandler = Request -> Response

/**
 * Represents an HTTP middleware, which sits between the client and base request handler.
 */
export type Middleware = RequestHandler -> RequestHandler

enum RequestMethods {
  Methods(List<RequestMethod>),
  All
}

export record RouteHandler {
  path: String,
  route: Route,
},
export enum Route {
  Endpoint(RequestMethods, RequestHandler),
  Router(Middleware, List<RouteHandler>)
}

/**
 * @section Values: Functions included in the Hopper module.
 */

/**
 * Writes a message to the WAGI log file.
 * 
 * @param val: The value to write out to the log
 */
export let log = val => {
  ignore(File.fdWrite(File.stderr, toString(val) ++ "\n"))
}

/**
 * Converts a string to an HTTP `RequestMethod`.
 * 
 * @param str: The string to convert to a `RequestMethod`
 * @returns A `RequestMethod` representing the string
 * 
 * @example Hopper.stringToMethod("GET") // RequestMethod.Get
 */
export let stringToMethod = str => {
  match (str) {
    "GET" => Get,
    "POST" => Post,
    "PUT" => Put,
    "DELETE" => Delete,
    "HEAD" => Head,
    "PATCH" => Patch,
    "CONNECT" => Connect,
    "OPTIONS" => Options,
    "TRACE" => Trace,
    _ => Method(str)
  }
}

/**
 * Converts a `RequestMethod` to a string describing the method.
 * 
 * @param method: `RequestMethod` to stringify
 * @returns A string representing the `RequestMethod`
 */
export let methodToString = method => {
  match (method) {
    Get => "GET",
    Post => "POST",
    Put => "PUT",
    Delete => "DELETE",
    Head => "HEAD",
    Patch => "PATCH",
    Connect => "CONNECT",
    Options => "OPTIONS",
    Trace => "TRACE",
    Method(str) => str,
  }
}

/**
 * Converts a response status to its corresponding status code.
 * 
 * @param status: An `HttpStatus` to get the status code of
 * @returns A status code for the response status
 */
export let statusCode = status => {
  match (status) {
    Continue => 100,
    SwitchingProtocols => 101,

    HttpOk => 200,
    Created => 201,
    Accepted => 202,
    NonAuthoritativeInformation => 203,
    NoContent => 204,
    ResetContent => 205,
    ParialContent => 206,

    MultipleChoices => 300,
    MovedPermanently => 301,
    Found => 302,
    SeeOther => 303,
    NotModified => 304,
    TemporaryRedirect => 307,
    PermanentRedirect => 308,

    BadRequest => 400,
    Unauthorized => 401,
    PaymentRequired => 402,
    Forbidden => 403,
    NotFound => 404,
    MethodNotAllowed => 405,
    NotAcceptable => 406,
    ProxyAuthenticationRequired => 407,
    RequestTimeout => 408,
    Conflict => 409,
    Gone => 410,
    LengthRequired => 411,
    PreconditionFailed => 412,
    PayloadTooLarge => 413,
    UriTooLong => 414,
    UnsupportedMediaType => 415,
    RangeNotSatisfiable => 416,
    ExpectationFailed => 417,
    ImATeapot => 418,
    MisdirectedRequest => 421,
    TooEarly => 425,
    UpgradeRequired => 426,
    PrecoditionRequired => 428,
    TooManyRequests => 429,
    RequestHeaderFieldsTooLarge => 431,
    UnavailableForLegalReasons => 451,

    InternalServerError => 500,
    NotImplemented => 501,
    BadGateway => 502,
    ServiceUnavailable => 503,
    GatewayTimeout => 504,
    HttpVersionNotSupported => 505,
    VariantAlsoNegotiates => 506,
    NotExtended => 510,
    NetworkAuthenticationRequired => 511,
    
    HttpStatus(status) => status
  }
}

let isStatusType = beginRange => status => {
  let code = statusCode(status)
  let endRange = beginRange + 100
  code >= beginRange && code < endRange
}

export let isInformational = isStatusType(100)
export let isSuccessful = isStatusType(200)
export let isRedirection = isStatusType(300)
export let isClientError = isStatusType(400)
export let isServerError = isStatusType(500)

// credit to https://github.com/deislabs/wagi-fileserver for the media types
let mediaTypes = Map.fromList([
  // Text formats
  ("txt", "text/plain"),
  ("md", "text/plain"),
  ("mdown", "text/plain"),
  ("htm", "text/html"),
  ("html", "text/html"),
  ("xhtml", "application/xhtml+xml"),
  ("xml", "application/xml"),
  ("css", "text/css"),
  ("ics", "text/calendar"),

  // Serialization formats
  ("json", "application/json"),
  ("jsonld", "application/ld+json"),
  ("toml", "application/toml"),
  ("yaml", "application/yaml"),

  // Applications
  // According to MSDN, prefered is text/javascript
  ("js", "text/javascript"),
  ("mjs", "text/javascript"),
  ("wasm", "application/wasm"),
  ("csv", "text/csv"),
  ("sh", "application/x-sh"),

  // Images
  ("apng", "image/apng"),
  ("avif", "image/avif"),
  ("png", "image/png"),
  ("png", "image/png"),
  ("jpg", "image/jpeg"),
  ("jpeg", "image/jpeg"),
  ("pjpeg", "image/jpeg"),
  ("pjp", "image/jpeg"),
  ("jfif", "image/jpeg"),
  ("gif", "image/gif"),
  ("tif", "image/tiff"),
  ("tiff", "image/tiff"),
  ("webp", "image/webp"),
  ("svg", "image/svg+xml"),
  ("bmp", "image/bmp"),
  ("ico", "image/vnd.microsoft.icon"),

  // Audio/Video
  ("aac", "audio/aac"),
  ("avi", "video/x-msvideo"),
  ("wav", "audio/wave"),
  ("webm", "video/webm"),
  ("mp3", "audio/mpeg"),
  ("mp4", "video/mp4"),
  ("mpeg", "video/mpeg"),
  ("oga", "audio/ogg"),
  ("ogv", "video/ogg"),
  ("ogx", "application/ogg"),
  ("ts", "video/mp2t"),

  // Compressed
  ("bz2", "application/x-bzip2"),
  ("tbz", "application/x-bzip2"),
  ("tbz2", "application/x-bzip2"),
  ("gz", "application/gzip"),
  ("rar", "application/vnd.rar"),
  ("tar", "text/x-tar"),
  ("tgz", "application/gzip"),
  ("jar", "application/java-archive"),
  ("mpkg", "application/vnd.apple.installer+xml"),
  ("zip", "application/zip"),
  ("7z", "application/x-7z-compressed"),

  // Binary
  ("azw", "application/vnd.amazon.ebook"),
  ("bin", "application/octet-stream"),
  ("doc", "application/msword"),
  (
    "docx",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  ),
  ("epub", "application/epub+zip"),
  ("odp", "application/vnd.oasis.opendocument.presentation"),
  ("ods", "application/vnd.oasis.opendocument.spreadsheet"),
  ("odt", "application/vnd.oasis.opendocument.text"),
  ("pdf", "application/pdf"),
  ("ppt", "application/vnd.ms-powerpoint"),
  (
    "pptx",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  ),
  ("rtf", "application/rtf"),
  ("vsd", "application/vnd.visio"),
  ("xls", "application/vnd.ms-excel"),
  (
    "xlsx",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  ),

  // Fonts
  ("eot", "application/vnd.ms-fontobject"),
  ("otf", "font/otf"),
  ("ttf", "font/ttf"),
  ("woff", "font/woff"),
  ("woff2", "font/woff2"),
])

/**
 * Guesses the MIME type of a media file by its filename extension.
 * 
 * @param fileName: The filename to guess the MIME type of
 * @returns A MIME type string for the filename
 */
export let guessMimeType = fileName => {
  match (String.lastIndexOf(".", fileName)) {
    Some(i) => {
      let extension = String.slice(i + 1, String.length(fileName), fileName)
      Option.unwrapWithDefault("application/octet-stream", Map.get(extension, mediaTypes))
    },
    None => "application/octet-stream",
  }
}

export let middlewares: List<Middleware> -> Middleware = mws => handler => {
  List.reduceRight((mw, handler) => mw(handler), handler, mws)
}
// TODO add middlewares: authentication, logging, etc

// TODO add cookies
// TODO implement all suggestions in https://datatracker.ietf.org/doc/html/rfc3875
// TODO percent encoding and such

export let response = (status, headers, body) => {
  { status, headers, body }
}

/**
 * Creates a new `Response` from an existing response, but with the response status code changed.
 * 
 * @param status: The desired HTTP status
 * @param response: The base response
 * @returns A new `Response` with the desired HTTP status
 */
export let status = (status, response) => {
  let { headers, body, _ } = response
  { status, headers, body }
}

/**
 * Creates a new OK `Response` with a text body and `"text/plain"` Content-Type.
 * 
 * @param body: The text body to create the `Response` with
 * @returns A new text `Response`
 */
export let text = body => {
  status: HttpOk,
  headers: Map.fromList([("Content-Type", "text/plain")]),
  body
}

/**
 * Creates a new OK `Response` with a JSON string body and `"application/json"` Content-Type.
 * 
 * Note: the argument type will likely be changed to a more friendly JSON
 * representation once https://github.com/grain-lang/grain/pull/1133 gets
 * merged.
 * 
 * @param body: The JSON body to create the `Response` with
 * @returns A new JSON `Response`
 */
export let json = body => {
  status: HttpOk,
  headers: Map.fromList([("Content-Type", "application/json")]),
  body
}

/**
 * Creates a new OK `Response` with the specified content type.
 * 
 * @param contentType: The Content-Type to set for the `Response`
 * @param body: The body of the response
 * @returns A new `Response` with the given content type
 */
export let contentType = (contentType, body) => {
  status: HttpOk,
  headers: Map.fromList([("Content-Type", contentType)]),
  body
}

export let notFound = {
  status: NotFound,
  headers: Map.fromList([("Content-Type", "text/plain")]),
  body: "Route Not Found"
}

/**
 * Creates a new `Response` from a static file on the server at the given path.
 * 
 * @param filePath: The path of the file to search for on the server
 * @returns A new OK `Response` if the file is found, or a "Not Found" reponse otherwise
 */
export let file = filePath => {
  let result = File.pathOpen(File.pwdfd, [], filePath, [], [File.FdFilestats, File.FdRead], [], [])

  match (result) {
    Err(_) => {
      status: NotFound,
      headers: Map.fromList([("Content-Type", "text/plain")]),
      body: "404 File Not Found"
    },
    Ok(fd) => {
      let stats = Result.unwrap(File.fdFilestats(fd))
      let (contents, _) = Result.unwrap(File.fdRead(fd, Int64.toNumber(stats.size)))
      File.fdClose(fd)

      {
        status: HttpOk,
        headers: Map.fromList([("Content-Type", guessMimeType(filePath))]),
        body: contents
      }
    }
  }
}

// TODO consider removing external redirect and merging into one
/**
 * Creates a new redirection `Response` to another route on the server.
 * 
 * @param path: The local path to redirect to
 * @param req: The incoming `Request`
 * @returns A new redirection `Response` with status code "302 Found"
 */
export let redirect = (path, req) => {
  let item = key => Option.unwrap(Map.get(key, req._wagiEnv))
  let protocol = if (String.startsWith("https://", item("X_FULL_URL"))) "https://" else "http://"
  let baseUrl = protocol ++ item("SERVER_NAME") ++ ":" ++ item("SERVER_PORT")
  {
    status: Found,
    headers: Map.fromList([("Location", baseUrl ++ path)]),
    body: "Redirected to " ++ path
  }
}

/**
 * Creates a new redirection `Response` to an arbitrary URL.
 * 
 * @param url: The URL to redirect to
 * @returns A new redirection `Response` with status code "302 Found"
 */
export let redirectExternal = url => {
  status: Found,
  headers: Map.fromList([("Location", url)]),
  body: "Redirected to " ++ url
}

let routeHandler = (path, methods, handler) => {
  { path, route: Endpoint(methods, handler) }
}

/**
 * Creates a new `RouteHandler` for handling GET requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `RouteHandler`
 */
export let get = (path, handler) => {
  routeHandler(path, Methods([Get]), handler)
}

export let post = (path, handler) => {
  routeHandler(path, Methods([Post]), handler)
}

export let put = (path, handler) => {
  routeHandler(path, Methods([Put]), handler)
}

export let delete = (path, handler) => {
  routeHandler(path, Methods([Delete]), handler)
}

export let head = (path, handler) => {
  routeHandler(path, Methods([Head]), handler)
}

export let patch = (path, handler) => {
  routeHandler(path, Methods([Patch]), handler)
}

export let connect = (path, handler) => {
  routeHandler(path, Methods([Connect]), handler)
}

export let options = (path, handler) => {
  routeHandler(path, Methods([Options]), handler)
}

export let trace = (path, handler) => {
  routeHandler(path, Methods([Trace]), handler)
}

export let methods = (methods, path, handler) => {
  routeHandler(path, Methods(methods), handler)
}

export let all = (path, handler) => {
  routeHandler(path, All, handler)
}

// TODO rename Router variant to Routes or something
// TODO integrate testing
export let scope = (path, routeHandlers) => {
  { path, route: Router(identity, routeHandlers) }
}

export let scopeWithMiddleware = (path, middleware, routeHandlers) => {
  { path, route: Router(middleware, routeHandlers) }
}

let genericErrMsg = "make sure you are running in a properly configured WAGI environment"
let failWithMsg = msg => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg
let failWithMsgWithErr = (msg, err) => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg ++ "; err " ++ toString(err)

let outputResponse = response => {
  let { headers, body, status } = response
  Map.forEach((key, val) => {
    let line = key ++ ": " ++ val
    let safeLine = Array.reduce(
      (str, c) => str ++ (if (c == '\n') "\\n" else Char.toString(c)),
      "",
      String.explode(line)
    )
    print(safeLine)
  }, headers)
  print("Status: " ++ toString(statusCode(status)) ++ "\n")
  print(body)
}

let readEnv = () => {
  let vars = match (Process.env()) {
    Ok(vars) => vars,
    Err(err) => failWithMsgWithErr("Unable to read system environment variables", err)
  }

  Map.fromArray(Array.map(var => {
    match (String.indexOf("=", var)) {
      Some(i) => {
        let varName = String.slice(0, i, var)
        let varVal = String.slice(i + 1, String.length(var), var)
        (varName, varVal)
      },
      None => failWithMsg("Error processing environment variable " ++ var)
    }
  }, vars))
}

let getReqMethod = wagiEnv => {
  match (Map.get("REQUEST_METHOD", wagiEnv)) {
    Some(reqMethod) => stringToMethod(reqMethod),
    _ => failWithMsg("Did not find \"REQUEST_METHOD\" in request")
  }
}

let toLower = str => {
  String.implode(Array.map(c => {
    let code = Char.code(c)
    if (code >= 65 && code <= 90) Char.fromCode(code + 32) else c
  }, String.explode(str)))
}

let headerNormed = str => {
  String.implode(Array.map(
    c => if (c == '-') '_' else c,
    String.explode(toLower(str))
  ))
}

export let joinedQuery = (key, delim, req) => {
  Option.map(val => match (val) {
    SingleVal(val) => val,
    MultiVal(vals) => List.join(delim, vals)
  }, Map.get(key, req.query))
}

// /**
//  * Extracts an HTTP header from the given request with the given key, case-insensitive.
//  * 
//  * @param key: The header name to get
//  * @param req: The incoming `Request`
//  * 
//  * @example Hopper.header("Content-Type", req) == Hopper.header("content-type", req) // true
//  */
// export let header = (key, req) => {
//   let key = headerNormed(key)
//   let httpVals = List.filter(((key, _)) => String.startsWith("HTTP_", key), Map.toList(req._wagiEnv))
//   let headers = Map.fromList(List.map(((key, val)) => {
//     let key = headerNormed(String.slice(5, String.length(key), key))
//     (key, val)
//   }, httpVals))
//   Map.get(key, headers)
// }

export let path = req => {
  Map.get("PATH_INFO", req._wagiEnv)
}

export let param = (key, req) => {
  Option.expect("URL path param " ++ key ++ " expected to exist on request but did not", Map.get(key, req.params))
}

export let method = req => {
  getReqMethod(req._wagiEnv)
}

export let header = (key, msg) => {
  let key = headerNormed(key)
  let header = List.find(
    ((headerKey, val)) => headerNormed(headerKey) == key,
    Map.toList(msg.headers)
  )
  match (header) {
    Some((_, val)) => Some(val),
    None => None
  }
}

export let setVariable = (key, value, msg) => {
  Map.set(key, Marshal.marshal(value), msg.variables)
}

export let getVariable = (key, msg) => {
  Marshal.unmarshal(Map.get(key, msg.variables))
}

// export let withLogging: Middleware = next => req => {
//   let begin = Time.monotonicTime()
//   next(req)
//   let end = Time.monotonicTime()
//   log(methodToString(req.method) ++ " " ++ req.fullUrl ++ " ")
// }

// TODO finish
export let withCors = next => req => {
  let res = next(req)
  // handle CORS "preflight" request
  if (res == notFound && req.method == Options) {
    { status: NoContent, headers: Map.fromList([
      ("Access-Control-Allow-Methods", "GET,HEAD,PUT,PATCH,POST,DELETE"),
      ("Access-Control-Allow-Origin", "*"),
      ("Access-Control-Allow-Headers", "*")
    ]), body: "" }
  } else {
    res
  }
}
// /**
//  * Parses an HTTP request with `Content-Type: application/x-www-form-urlencoded`
//  * and form data into a `Map` mapping form item names to their values. The
//  * keys/values are expected to be in the URL query string on GET requests and in
//  * the body on POST requests.
//  * 
//  * @param req: The incoming `Request`
//  * @returns A `Map` mapping form item names to their values
//  */
// export let parseForm = req => {
//   match (req.method) {
//     Get => req.query,
//     Post when header("Content-Type", req) == Some("application/x-www-form-urlencoded") => {
//       let parts = String.split("&", req.body)
//       Map.fromArray(Array.map(part => {
//         match (String.indexOf("=", part)) {
//           Some(i) => {
//             let partName = String.slice(0, i, part)
//             let partVal = String.slice(i + 1, String.length(part), part)
//             (partName, partVal)
//           },
//           None => (part, "")
//         }
//       }, parts))
//     },
//     _ => Map.make(),
//   }
// }

// let parseContentDispositionHeader = headers => {
//   let contentDispositionLine = List.find(
//     line => String.startsWith("content-disposition", toLower(line)),
//     headers
//   )
//   match (contentDispositionLine) {
//     None => None,
//     Some(contentDispositionLine) => {
//       let regex = Result.unwrap(Regex.make("content-disposition:\\s*form-data;\\s*name=\"(.+)\""))
//       match (Regex.find(regex, toLower(contentDispositionLine))) {
//         None => None,
//         Some(reMatch) => {
//           let (nameBeginI, nameEndI) = reMatch.groupPosition(1)
//           let name = String.slice(nameBeginI, nameEndI, contentDispositionLine)
//           Some(name)
//         }
//       }

//     }
//   }
// }

// let readMultipart = (body, boundary) => {
//   let lines = Array.toList(String.split("\n", body))
//   let lines = List.takeWhile(line => line != "--" ++ boundary ++ "--", lines)
//   let parts = List.reduceRight(
//     (line, parts) => {
//       if (line == "--" ++ boundary) {
//         let [partLines, ...rest] = parts
//         [[line, ...partLines], rest]
//       } else {
//         [[], parts]
//       }
//     },
//     [[]],
//     lines
//   )
//   List.reduce(
//     partLines => {
//       let lineEmpty = line => String.strip(line) == ""

//       let headers = List.takeWhile(line => !lineEmpty(line), partLines)
//       let body = List.dropWhile(lineEmpty, List.dropWhile(line => !lineEmpty(line), partLines))

//       let itemName = parseContentDispositionHeader(headers)
//       let bodyStr = String.join("\n", body)
//     },
//     parts
//   )
// }

// export let parseMultipartForm = req => {
//   match (req.method) {
//     Post => match (header("Content-Type", req)) {
//       Some(val) when String.startsWith("multipart/form-data;", val) => {
//         let boundary = String.trim(String.slice(String.length("multipart/form-data;"), String.length(val), val))
//         if (String.startsWith("boundary=", boundary)) {
//           // TODO consider quotes
//           let boundaryVal = String.slice(String.length("boundary="), String.length(boundary), val)
//           readMultipart(req.body, boundaryVal)
//         } else {
//           Map.make()
//         }
//       },
//       _ => Map.make()
//     },
//     _ => Map.make(),
//   }
// }

// TODO json deserialization
let readBody = wagiEnv => {
  let bodyLengthStr = match (Map.get("CONTENT_LENGTH", wagiEnv)) {
    Some(val) => val,
    None => failWithMsg("Did not find \"CONTENT_LENGTH\" in request")
  }

  let bodyLength = match (Number.parseInt(bodyLengthStr, 10)) {
    Ok(num) => num,
    Err(err) => failWithMsgWithErr("Failed to parse \"CONTENT_LENGTH\" from request to an integer", err)
  }

  match (File.fdRead(File.stdin, bodyLength)) {
    Ok((body, _)) => body,
    Err(err) => failWithMsgWithErr("Failed to read request body", err)
  }
}

let readArgs = () => {
  match (Process.argv()) {
    Ok(args) => {
      let [path, ...queryParamList] = Array.toList(args)
      let queryParamMap = Map.make()
      List.forEach(param => {
        let (param, val) = match (String.indexOf("=", param)) {
          // some query params may only have a key, set value to empty string in this case
          None => (param, ""),
          Some(i) => {
            let varName = String.slice(0, i, param)
            let varVal = String.slice(i + 1, String.length(param), param)
            (varName, varVal)
          }
        }
        match (Map.get(param, queryParamMap)) {
          None => Map.set(param, SingleVal(val), queryParamMap),
          Some(SingleVal(currVal)) => Map.set(param, MultiVal([currVal, val]), queryParamMap),
          Some(MultiVal(currVals)) => Map.set(param, MultiVal(List.append(currVals, [val])), queryParamMap)
        }
      }, queryParamList)
      (path, queryParamMap)
    },
    Err(err) => failWithMsgWithErr("Unable to read system arguments", err)
  }
}
    
// TODO maybe normalize urls or something to make more robust; also currently trailing slash does not work if in URL
let matchRestRegex = Result.unwrap(Regex.make("/\\*$"))
// a bit of a hack to not capture regex groups specified in route.
// if something is going wrong with matching patterns it may be due to this
let captureGroupRegex = Result.unwrap(Regex.make("(?<!\\\\)\\("))
let replaceWithCapturesRegex = Result.unwrap(Regex.make("<\\w+\\(\\?:(.*)\\)>"))
let paramRegex = Result.unwrap(Regex.make("<\\w+>"))
let customParamRegex = Result.unwrap(Regex.make("<\\w+\\((.*)\\)>"))
let paramNameRegex = Result.unwrap(Regex.make("<(\\w+)>"))
let customParamNameRegex = Result.unwrap(Regex.make("<(\\w+)\\(.*\\)>"))
let slashAtEndRegex = Result.unwrap(Regex.make("/$"))
let noDollarSignAtEnd = Result.unwrap(Regex.make("(?<!\\$)$"))

let preprocessRouteRegex = route => {
  let routeRegex = List.reduce(
    (str, (regex, replaceWith)) => {
      // log("rr " ++ str)
      Regex.replaceAll(regex, str, replaceWith)
    },
    route,
    [
      (matchRestRegex, "/.*"),
      (matchRestRegex, "/.*"),
      (captureGroupRegex, "(?:"),
      (replaceWithCapturesRegex, "($1)"),
      (customParamRegex, "($1)"),
      (paramRegex, "(\\w+)"),
      (slashAtEndRegex, ""),
      (noDollarSignAtEnd, "$"),
    ]
  )

  match (Regex.make(routeRegex)) {
    Err(_) => failWithMsg("Invalid route path " ++ route),
    Ok(routeRegex) => routeRegex
  }
}

let findReqHandler = (reqMethod, path, routeHandler) => {
  let pathVars = Map.make()
  let notFoundHandler = req => notFound

  let rec findReqHandlerHelper = (pathSegment, routeHandler) => {
    let paramNames = List.map(
      (matchRes: Regex.MatchResult) => Option.unwrap(matchRes.group(1)),
      List.append(
        Regex.findAll(paramNameRegex, routeHandler.path),
        Regex.findAll(customParamNameRegex, routeHandler.path)
      )
    )

    let routeRegex = preprocessRouteRegex(routeHandler.path)
    let pathMatch = Regex.find(routeRegex, pathSegment)
    match (pathMatch) {
      None => notFoundHandler,
      Some(pathMatch) => {
        let (thisPathStartI, thisPathEndI) = Option.unwrap(pathMatch.groupPosition(0))
        if (thisPathStartI != 0) {
          notFoundHandler
        } else {
          let matchedSegment = Option.unwrap(pathMatch.group(0))
          log("matchSeg " ++ matchedSegment)
          if (pathMatch.numGroups > 1) {
            let [_, ...paramVals] = Array.toList(Array.map(grp => Option.unwrap(grp), pathMatch.allGroups()))
            List.forEach(((paramName, paramVal)) => {
              Map.set(paramName, paramVal, pathVars)
            }, List.zip(paramNames, paramVals))
          }
          let reqHandler = match (routeHandler.route) {
            Endpoint(handlerMethods, reqHandler) => {
              // if there is more left to the path e.g. if the route matcher is
              // /hi but the URL hit is /hi/hello, then consider it not matched
              if (thisPathEndI != String.length(pathSegment)) {
                notFoundHandler
              } else {
                match (handlerMethods) {
                  All => reqHandler,
                  Methods(methods) when List.contains(reqMethod, methods) => reqHandler,
                  _ => notFoundHandler,
                }
              }
            },
            Router(middleware, routeHandlers) => {
              let nextPathSegment = String.slice(thisPathEndI, String.length(pathSegment), pathSegment)
              let nextPathSegment = if (!String.startsWith("/", nextPathSegment)) "/" ++ nextPathSegment else nextPathSegment
              let reqHandler = List.reduce(
                (found, routeHandler) => {
                  if (found == notFoundHandler) {
                    findReqHandlerHelper(nextPathSegment, routeHandler)
                  } else {
                    found
                  }
                },
                notFoundHandler,
                routeHandlers
              )
              let nfc = notFoundHandler
              log("not this one " ++ toString(notFoundHandler == reqHandler))
              log("this one " ++ toString(nfc == notFoundHandler))
              let m = middleware(reqHandler)
              log("did not blow up")
              m
            }
          }
          reqHandler
        }
      }
    }
  }

  (findReqHandlerHelper(path, routeHandler), pathVars)
}

/**
 * Entry point for creating a server, taking a root route handler.
 * 
 * @param routeHandler: The root route handler for the server
 */
export let serve = routeHandler => {
  let (path, query) = readArgs()
  let wagiEnv = readEnv()

  // TODO handling of params with same names e.g. asdf=a&asdf=b
  let (reqHandler, params) = findReqHandler(getReqMethod(wagiEnv), path, routeHandler)
  log("reqHandler " ++ toString(reqHandler))
  // let reqHandler = match (reqHandler) {
  //   None => req => notFound,
  //   Some(handler) => handler
  // }
  let request = {
    variables: Map.make(),
    _wagiEnv: wagiEnv,
    query,
    body: readBody(wagiEnv)
  }
  let response = reqHandler(request)
  outputResponse(response)
}
