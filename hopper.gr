/**
 * @module Hopper: An HTTP microframework for the Grain programming language.
 */

import Option from "option"
import Result from "result"
import Number from "number"
import Map from "map"
import List from "list"
import Array from "array"
import String from "string"
import Char from "char"
import Regex from "regex"
import Int64 from "int64"
import Process from "sys/process"
import File from "sys/file"

/**
 * @section Types: Type declarations included in the Hopper module.
 */

/**
 * Represents various HTTP request methods.
 */
export enum RequestMethod {
  Get,
  Post,
  Put,
  Delete,
  Head,
  Patch,
  Connect,
  Options,
  Trace,
  Method(String)
}

/**
 * Represents an incoming HTTP request.
 */
export record Request {
  mut variables: Map.Map<String, String>,
  wagiEnv: Map.Map<String, String>,
  method: RequestMethod,
  params: Map.Map<String, String>,
  query: Map.Map<String, String>,
  fullUrl: String,
  body: String,
}

/**
 * Represents HTTP response statuses.
 */
export enum Status {
  Continue,
  SwitchingProtocols,

  HttpOk,
  Created,
  Accepted,
  NonAuthoritativeInformation,
  NoContent,
  ResetContent,
  ParialContent,

  MultipleChoices,
  MovedPermanently,
  Found,
  SeeOther,
  NotModified,
  TemporaryRedirect,
  PermanentRedirect,

  BadRequest,
  Unauthorized,
  PaymentRequired,
  Forbidden,
  NotFound,
  MethodNotAllowed,
  NotAcceptable,
  ProxyAuthenticationRequired,
  RequestTimeout,
  Conflict,
  Gone,
  LengthRequired,
  PreconditionFailed,
  PayloadTooLarge,
  UriTooLong,
  UnsupportedMediaType,
  RangeNotSatisfiable,
  ExpectationFailed,
  ImATeapot,
  MisdirectedRequest,
  TooEarly,
  UpgradeRequired,
  PrecoditionRequired,
  TooManyRequests,
  RequestHeaderFieldsTooLarge,
  UnavailableForLegalReasons,

  InternalServerError,
  NotImplemented,
  BadGateway,
  ServiceUnavailable,
  GatewayTimeout,
  HttpVersionNotSupported,
  VariantAlsoNegotiates,
  NotExtended,
  NetworkAuthenticationRequired,

  HttpStatus(Number)
}

/**
 * Represents an HTTP response.
 */
export record Response {
  status: Status,
  headers: Map.Map<String, String>,
  body: String,
}

/**
 * Represents an HTTP request handler which processes a request and returns a response.
 */
export type RequestHandler = Request -> Response

/**
 * Represents an HTTP middleware, which sits between the client and base request handler.
 */
export type Middleware = RequestHandler -> RequestHandler

enum RequestMethods {
  Methods(List<RequestMethod>),
  All
}

export record RouteHandler {
  path: String,
  route: Route,
},
export enum Route {
  Endpoint(RequestMethods, RequestHandler),
  Router(Option<Middleware>, List<RouteHandler>)
}

/**
 * @section Values: Functions included in the Hopper module.
 */

/**
 * Writes a message to the WAGI log file.
 * 
 * @param val: The value to write out to the log
 */
export let log = val => {
  ignore(File.fdWrite(File.stderr, toString(val) ++ "\n"))
}

/**
 * Converts a string to an HTTP `RequestMethod`.
 * 
 * @param str: The string to convert to a `RequestMethod`
 * @returns A `RequestMethod` representing the string
 * 
 * @example Hopper.stringToMethod("GET") // RequestMethod.Get
 */
export let stringToMethod = str => {
  match (str) {
    "GET" => Get,
    "POST" => Post,
    "PUT" => Put,
    "DELETE" => Delete,
    "HEAD" => Head,
    "PATCH" => Patch,
    "CONNECT" => Connect,
    "OPTIONS" => Options,
    "TRACE" => Trace,
    _ => Method(str)
  }
}

/**
 * Converts a `RequestMethod` to a string describing the method.
 * 
 * @param method: `RequestMethod` to stringify
 * @returns A string representing the `RequestMethod`
 */
export let methodToString = method => {
  match (method) {
    Get => "GET",
    Post => "POST",
    Put => "PUT",
    Delete => "DELETE",
    Head => "HEAD",
    Patch => "PATCH",
    Connect => "CONNECT",
    Options => "OPTIONS",
    Trace => "TRACE",
    Method(str) => str,
  }
}

/**
 * Converts a response status to its corresponding status code.
 * 
 * @param status: An `HttpStatus` to get the status code of
 * @returns A status code for the response status
 */
export let statusCode = status => {
  match (status) {
    Continue => 100,
    SwitchingProtocols => 101,

    HttpOk => 200,
    Created => 201,
    Accepted => 202,
    NonAuthoritativeInformation => 203,
    NoContent => 204,
    ResetContent => 205,
    ParialContent => 206,

    MultipleChoices => 300,
    MovedPermanently => 301,
    Found => 302,
    SeeOther => 303,
    NotModified => 304,
    TemporaryRedirect => 307,
    PermanentRedirect => 308,

    BadRequest => 400,
    Unauthorized => 401,
    PaymentRequired => 402,
    Forbidden => 403,
    NotFound => 404,
    MethodNotAllowed => 405,
    NotAcceptable => 406,
    ProxyAuthenticationRequired => 407,
    RequestTimeout => 408,
    Conflict => 409,
    Gone => 410,
    LengthRequired => 411,
    PreconditionFailed => 412,
    PayloadTooLarge => 413,
    UriTooLong => 414,
    UnsupportedMediaType => 415,
    RangeNotSatisfiable => 416,
    ExpectationFailed => 417,
    ImATeapot => 418,
    MisdirectedRequest => 421,
    TooEarly => 425,
    UpgradeRequired => 426,
    PrecoditionRequired => 428,
    TooManyRequests => 429,
    RequestHeaderFieldsTooLarge => 431,
    UnavailableForLegalReasons => 451,

    InternalServerError => 500,
    NotImplemented => 501,
    BadGateway => 502,
    ServiceUnavailable => 503,
    GatewayTimeout => 504,
    HttpVersionNotSupported => 505,
    VariantAlsoNegotiates => 506,
    NotExtended => 510,
    NetworkAuthenticationRequired => 511,
    
    HttpStatus(status) => status
  }
}

// credit to https://github.com/deislabs/wagi-fileserver for the media types
let mediaTypes = Map.fromList([
  // Text formats
  ("txt", "text/plain"),
  ("md", "text/plain"),
  ("mdown", "text/plain"),
  ("htm", "text/html"),
  ("html", "text/html"),
  ("xhtml", "application/xhtml+xml"),
  ("xml", "application/xml"),
  ("css", "text/css"),
  ("ics", "text/calendar"),

  // Serialization formats
  ("json", "application/json"),
  ("jsonld", "application/ld+json"),
  ("toml", "application/toml"),
  ("yaml", "application/yaml"),

  // Applications
  // According to MSDN, prefered is text/javascript
  ("js", "text/javascript"),
  ("mjs", "text/javascript"),
  ("wasm", "application/wasm"),
  ("csv", "text/csv"),
  ("sh", "application/x-sh"),

  // Images
  ("apng", "image/apng"),
  ("avif", "image/avif"),
  ("png", "image/png"),
  ("png", "image/png"),
  ("jpg", "image/jpeg"),
  ("jpeg", "image/jpeg"),
  ("pjpeg", "image/jpeg"),
  ("pjp", "image/jpeg"),
  ("jfif", "image/jpeg"),
  ("gif", "image/gif"),
  ("tif", "image/tiff"),
  ("tiff", "image/tiff"),
  ("webp", "image/webp"),
  ("svg", "image/svg+xml"),
  ("bmp", "image/bmp"),
  ("ico", "image/vnd.microsoft.icon"),

  // Audio/Video
  ("aac", "audio/aac"),
  ("avi", "video/x-msvideo"),
  ("wav", "audio/wave"),
  ("webm", "video/webm"),
  ("mp3", "audio/mpeg"),
  ("mp4", "video/mp4"),
  ("mpeg", "video/mpeg"),
  ("oga", "audio/ogg"),
  ("ogv", "video/ogg"),
  ("ogx", "application/ogg"),
  ("ts", "video/mp2t"),

  // Compressed
  ("bz2", "application/x-bzip2"),
  ("tbz", "application/x-bzip2"),
  ("tbz2", "application/x-bzip2"),
  ("gz", "application/gzip"),
  ("rar", "application/vnd.rar"),
  ("tar", "text/x-tar"),
  ("tgz", "application/gzip"),
  ("jar", "application/java-archive"),
  ("mpkg", "application/vnd.apple.installer+xml"),
  ("zip", "application/zip"),
  ("7z", "application/x-7z-compressed"),

  // Binary
  ("azw", "application/vnd.amazon.ebook"),
  ("bin", "application/octet-stream"),
  ("doc", "application/msword"),
  (
    "docx",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  ),
  ("epub", "application/epub+zip"),
  ("odp", "application/vnd.oasis.opendocument.presentation"),
  ("ods", "application/vnd.oasis.opendocument.spreadsheet"),
  ("odt", "application/vnd.oasis.opendocument.text"),
  ("pdf", "application/pdf"),
  ("ppt", "application/vnd.ms-powerpoint"),
  (
    "pptx",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  ),
  ("rtf", "application/rtf"),
  ("vsd", "application/vnd.visio"),
  ("xls", "application/vnd.ms-excel"),
  (
    "xlsx",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  ),

  // Fonts
  ("eot", "application/vnd.ms-fontobject"),
  ("otf", "font/otf"),
  ("ttf", "font/ttf"),
  ("woff", "font/woff"),
  ("woff2", "font/woff2"),
])

/**
 * Guesses the MIME type of a media file by its filename extension.
 * 
 * @param fileName: The filename to guess the MIME type of
 * @returns A MIME type string for the filename
 */
export let guessMimeType = fileName => {
  match (String.lastIndexOf(".", fileName)) {
    Some(i) => {
      let extension = String.slice(i + 1, String.length(fileName), fileName)
      Option.unwrapWithDefault("application/octet-stream", Map.get(extension, mediaTypes))
    },
    None => "application/octet-stream",
  }
}

// export let withMiddlewares = (middlewares: List<Middleware>, handler) => {
//   List.reduce((h, mw) => mw(h), handler, middlewares)
// }

// TODO add middlewares: authentication, logging, etc

// TODO look into adding cookies
// TODO CORS

/**
 * Creates a new `Response` from an existing response, but with the response status code changed.
 * 
 * @param status: The desired HTTP status
 * @param response: The base response
 * @returns A new `Response` with the desired HTTP status
 */
export let status = (status, response) => {
  let { headers, body, _ } = response
  { status, headers, body }
}

/**
 * Creates a new OK `Response` with a text body and `"text/plain"` Content-Type.
 * 
 * @param body: The text body to create the `Response` with
 * @returns A new text `Response`
 */
export let text = body => {
  status: HttpOk,
  headers: Map.fromList([("Content-Type", "text/plain")]),
  body
}

/**
 * Creates a new OK `Response` with a JSON string body and `"application/json"` Content-Type.
 * 
 * @param body: The JSON body to create the `Response` with
 * @returns A new JSON `Response`
 */
export let json = body => {
  status: HttpOk,
  headers: Map.fromList([("Content-Type", "application/json")]),
  body
}

/**
 * Creates a new OK `Response` with the specified content type.
 * 
 * @param contentType: The Content-Type to set for the `Response`
 * @param body: The body of the response
 * @returns A new `Response` with the given content type
 */
export let contentType = (contentType, body) => {
  status: HttpOk,
  headers: Map.fromList([("Content-Type", contentType)]),
  body
}

// TODO consider streams
/**
 * Creates a new `Response` from a static file on the server at the given path.
 * 
 * @param filePath: The path of the file to search for on the server
 * @returns A new OK `Response` if the file is found, or a "Not Found" reponse otherwise
 */
export let file = filePath => {
  let result = File.pathOpen(File.pwdfd, [], filePath, [], [File.FdFilestats, File.FdRead], [], [])

  match (result) {
    Err(_) => {
      status: NotFound,
      headers: Map.fromList([("Content-Type", "text/plain")]),
      body: "404 File Not Found"
    },
    Ok(fd) => {
      let stats = Result.unwrap(File.fdFilestats(fd))
      let (contents, _) = Result.unwrap(File.fdRead(fd, Int64.toNumber(stats.size)))
      File.fdClose(fd)

      {
        status: HttpOk,
        headers: Map.fromList([("Content-Type", guessMimeType(filePath))]),
        body: contents
      }
    }
  }
}

// TODO test
/**
 * Creates a new redirection `Response` to another route on the server.
 * 
 * @param path: The local path to redirect to
 * @param req: The incoming `Request`
 * @returns A new redirection `Response` with status code "302 Found"
 */
export let redirect = (path, req) => {
  let item = key => Option.unwrap(Map.get(key, req.wagiEnv))
  let protocol = if (String.startsWith("https://", item("X_FULL_URL"))) "https://" else "http://"
  let baseUrl = protocol ++ item("SERVER_NAME") ++ ":" ++ item("SERVER_PORT")
  {
    status: Found,
    headers: Map.fromList([("Location", baseUrl ++ path)]),
    body: "Redirected to " ++ path
  }
}

/**
 * Creates a new redirection `Response` to an arbitrary URL.
 * 
 * @param url: The URL to redirect to
 * @returns A new redirection `Response` with status code "302 Found"
 */
export let redirectExternal = url => {
  status: Found,
  headers: Map.fromList([("Location", url)]),
  body: "Redirected to " ++ url
}

let routeHandler = (path, methods, handler) => {
  { path, route: Endpoint(methods, handler) }
}

/**
 * Creates a new `RouteHandler` for handling GET requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `RouteHandler`
 */
export let get = (path, handler) => {
  routeHandler(path, Methods([Get]), handler)
}

export let post = (path, handler) => {
  routeHandler(path, Methods([Post]), handler)
}

export let put = (path, handler) => {
  routeHandler(path, Methods([Put]), handler)
}

export let delete = (path, handler) => {
  routeHandler(path, Methods([Delete]), handler)
}

export let head = (path, handler) => {
  routeHandler(path, Methods([Head]), handler)
}

export let patch = (path, handler) => {
  routeHandler(path, Methods([Patch]), handler)
}

export let connect = (path, handler) => {
  routeHandler(path, Methods([Connect]), handler)
}

export let options = (path, handler) => {
  routeHandler(path, Methods([Options]), handler)
}

export let trace = (path, handler) => {
  routeHandler(path, Methods([Trace]), handler)
}

export let methods = (methods, path, handler) => {
  routeHandler(path, Methods(methods), handler)
}

export let all = (path, handler) => {
  routeHandler(path, All, handler)
}

export let router = (path, routeHandlers) => {
  { path, route: Router(None, routeHandlers) }
}

export let routerWithMiddleware = (path, middleware, routeHandlers) => {
  { path, route: Router(Some(middleware), routeHandlers) }
}

let genericErrMsg = "make sure you are running in a properly configured WAGI environment"
let failWithMsg = msg => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg
let failWithMsgWithErr = (msg, err) => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg ++ "; err " ++ toString(err)

let outputResponse = response => {
  let { headers, body, status } = response
  Map.forEach((key, val) => {
    let line = key ++ ": " ++ val
    let safeLine = Array.reduce(
      (str, c) => str ++ (if (c == '\n') "\\n" else Char.toString(c)),
      "",
      String.explode(line)
    )
    print(safeLine)
  }, headers)
  print("Status: " ++ toString(statusCode(status)) ++ "\n")
  print(body)
}

let readEnv = () => {
  let vars = match (Process.env()) {
    Ok(vars) => vars,
    Err(err) => failWithMsgWithErr("Unable to read system environment variables", err)
  }

  Map.fromArray(Array.map(var => {
    match (String.indexOf("=", var)) {
      Some(i) => {
        let varName = String.slice(0, i, var)
        let varVal = String.slice(i + 1, String.length(var), var)
        (varName, varVal)
      },
      None => failWithMsg("Error processing environment variable " ++ var)
    }
  }, vars))
}

let headerNormed = str => {
  String.implode(Array.map(c => {
    let code = Char.code(c)
    if (code >= 65 && code <= 90) {
      Char.fromCode(code + 32)
    } else if (c == '-') {
      '_'
    } else {
      c
    }
  }, String.explode(str)))
}

/**
 * Extracts an HTTP header from the given request with the given key, case-insensitive.
 * 
 * @param key: The header name to get
 * @param req: The incoming `Request`
 * 
 * @example Hopper.header("Content-Type", req) == Hopper.header("content-type", req) // true
 */
export let header = (key, req) => {
  let key = headerNormed(key)
  let httpVals = List.filter(((key, _)) => String.startsWith("HTTP_", key), Map.toList(req.wagiEnv))
  let headers = Map.fromList(List.map(((key, val)) => {
    let key = headerNormed(String.slice(5, String.length(key), key))
    (key, val)
  }, httpVals))
  Map.get(key, headers)
}

/**
 * Parses an HTTP request with `Content-Type: application/x-www-form-urlencoded`
 * and form data into a `Map` mapping form item names to their values. The
 * keys/values are expected to be in the URL query string on GET requests and in
 * the body on POST requests.
 * 
 * @param req: The incoming `Request`
 * @returns A `Map` mapping form item names to their values
 */
export let parseForm = req => {
  match (req.method) {
    Get => req.query,
    Post when header("Content-Type", req) == Some("application/x-www-form-urlencoded") => {
      let parts = String.split("&", req.body)
      Map.fromArray(Array.map(part => {
        match (String.indexOf("=", part)) {
          Some(i) => {
            let partName = String.slice(0, i, part)
            let partVal = String.slice(i + 1, String.length(part), part)
            (partName, partVal)
          },
          None => (part, "")
        }
      }, parts))
    },
    _ => Map.make(),
  }
}

// let readMultipart = (body, boundary) => {
//   let lines = Array.toList(String.split("\n", body))
//   let lines = List.takeWhile(line => line != "--" ++ boundary ++ "--", lines)
//   let parts = List.reduceRight(
//     (line, parts) => {
//       if (line == "--" ++ boundary) {
//         let [partLines, ...rest] = parts
//         [[line, ...partLines], rest]
//       } else {
//         [[], parts]
//       }
//     },
//     [[]],
//     lines
//   )
//   List.reduce(
//     part => {
      
//     },
//     parts
//   )
// }

// export let parseMultipartForm = req => {
//   match (req.method) {
//     Post => match (header("Content-Type", req)) {
//       Some(val) when String.startsWith("multipart/form-data;", val) => {
//         let boundary = String.trim(String.slice(String.length("multipart/form-data;"), String.length(val), val))
//         if (String.startsWith("boundary=", boundary)) {
//           // TODO consider quotes
//           let boundaryVal = String.slice(String.length("boundary="), String.length(boundary), val)
//           readMultipart(req.body, boundaryVal)
//         } else {
//           Map.make()
//         }
//       },
//       _ => Map.make()
//     },
//     _ => Map.make(),
//   }
// }

// TODO json deserialization
let readBody = wagiEnv => {
  let bodyLengthStr = match (Map.get("CONTENT_LENGTH", wagiEnv)) {
    Some(val) => val,
    None => failWithMsg("Did not find \"CONTENT_LENGTH\" in request")
  }

  let bodyLength = match (Number.parseInt(bodyLengthStr, 10)) {
    Ok(num) => num,
    Err(err) => failWithMsgWithErr("Failed to parse \"CONTENT_LENGTH\" from request to an integer", err)
  }

  match (File.fdRead(File.stdin, bodyLength)) {
    Ok((body, _)) => body,
    Err(err) => failWithMsgWithErr("Failed to read request body", err)
  }
}

let getReqMethod = wagiEnv => {
  match (Map.get("REQUEST_METHOD", wagiEnv)) {
    Some(reqMethod) => stringToMethod(reqMethod),
    _ => failWithMsg("Did not find \"REQUEST_METHOD\" in request")
  }
}

let readArgs = () => {
  match (Process.argv()) {
    Ok(args) => {
      let [path, ...queryParamList] = Array.toList(args)
      let queryParamMap = Map.fromList(List.map(
        param => match (String.indexOf("=", param)) {
          // some query params may only have a key, set value to empty string in this case
          None => (param, ""),
          Some(i) => {
            let varName = String.slice(0, i, param)
            let varVal = String.slice(i + 1, String.length(param), param)
            (varName, varVal)
          }
        },
        queryParamList
      ))
      (path, queryParamMap)
    },
    Err(err) => failWithMsgWithErr("Unable to read system arguments", err)
  }
}

let findReqHandler = (reqMethod, path, routeHandler) => {
  let pathVars = Map.make()

  let rec findReqHandlerHelper = (pathSegment, routeHandler) => {
    // TODO use different strategy and allow expaning of whole path
    let paramRegex = Result.unwrap(Regex.make(":\\w+"))
    let paramNames = List.map(
      (matchRes: Regex.MatchResult) => {
        let str = Option.unwrap(matchRes.group(0))
        // remove the colon at the beginning
        String.slice(1, String.length(str), str)
      },
      Regex.findAll(paramRegex, routeHandler.path)
    )
    let routeWithVarCaptures = Regex.replaceAll(paramRegex, routeHandler.path, "(\\w+)")
    let pathMatch = match (Regex.make(routeWithVarCaptures)) {
      Err(_) => failWithMsg("Invalid route path " ++ pathSegment),
      Ok(re) => Regex.find(re, pathSegment)
    }
    Option.flatMap((pathMatch: Regex.MatchResult) => {
      let (thisPathStartI, thisPathEndI) = Option.unwrap(pathMatch.groupPosition(0))
      if (thisPathStartI != 0) {
        None
      } else {
        let matchedSegment = Option.unwrap(pathMatch.group(0))
        if (pathMatch.numGroups > 1) {
          let [_, ...paramVals] = Array.toList(Array.map(grp => Option.unwrap(grp), pathMatch.allGroups()))
          List.forEach(((paramName, paramVal)) => {
            Map.set(paramName, paramVal, pathVars)
          }, List.zip(paramNames, paramVals))
        }
        let reqHandler = match (routeHandler.route) {
          Endpoint(handlerMethods, reqHandler) => match (handlerMethods) {
            All => Some(reqHandler),
            Methods(methods) when List.contains(reqMethod, methods) => Some(reqHandler),
            _ => None,
          },
          Router(middleware, routeHandlers) => {
            let mut nextPathSegment = String.slice(thisPathEndI, String.length(pathSegment), pathSegment)
            if (!String.startsWith("/", nextPathSegment)) {
              nextPathSegment = "/" ++ nextPathSegment
            }
            let reqHandler = List.reduce(
              (found, routeHandler) => match (found) {
                Some(_) => found,
                None => findReqHandlerHelper(nextPathSegment, routeHandler)
              },
              None,
              routeHandlers
            )
            let val = match ((middleware, reqHandler)) {
              (Some(middleware), Some(reqHandler)) => Some(middleware(reqHandler)),
              _ => reqHandler
            }
            val
          }
        }
        reqHandler
      }
    }, pathMatch)
  }

  (findReqHandlerHelper(path, routeHandler), pathVars)
}

/**
 * Entry point for creating a server, taking a root route handler.
 * 
 * @param routeHandler: The root route handler for the server
 */
export let serve = routeHandler => {
  let (path, query) = readArgs()
  let wagiEnv = readEnv()
  let reqMethod = getReqMethod(wagiEnv)
  let body = readBody(wagiEnv)

  // TODO handling of params with same names e.g. asdf=a&asdf=b
  let (reqHandler, params) = findReqHandler(reqMethod, path, routeHandler)
  let response = match (reqHandler) {
    None => {
      status: NotFound,
      headers: Map.fromList([("Content-Type", "text/plain")]),
      body: "404 Not Found"
    },
    Some(handler) => {
      let request = {
        variables: Map.make(),
        wagiEnv,
        method: reqMethod,
        params,
        query,
        fullUrl: "",
        body
      }
      handler(request)
    }
  }
  outputResponse(response)
}
