import Option from "option"
import Result from "result"
import Number from "number"
import Map from "map"
import List from "list"
import Array from "array"
import String from "string"
import Char from "char"
import Regex from "regex"
import Int64 from "int64"
import Process from "sys/process"
import File from "sys/file"

enum RequestMethod {
  Get,
  Post,
  Put,
  Delete,
  Head,
  Patch,
  Connect,
  Options,
  Trace
}

let toRequestMethod = str => {
  match (str) {
    "GET" => Some(Get),
    "POST" => Some(Post),
    "PUT" => Some(Put),
    "DELETE" => Some(Delete),
    "HEAD" => Some(Head),
    "PATCH" => Some(Patch),
    "CONNECT" => Some(Connect),
    "OPTIONS" => Some(Options),
    "TRACE" => Some(Trace),
    _ => None
  }
}

export record Request {
  mut variables: Map.Map<String, String>,
  wagiEnv: Map.Map<String, String>,
  method: RequestMethod,
  params: Map.Map<String, String>,
  query: Map.Map<String, String>,
  fullUrl: String,
  body: String,
}

export enum Status {
  Continue,
  SwitchingProtocols,

  HttpOk,
  Created,
  Accepted,
  NonAuthoritativeInformation,
  NoContent,
  ResetContent,
  ParialContent,

  MultipleChoices,
  MovedPermanently,
  Found,
  SeeOther,
  NotModified,
  TemporaryRedirect,
  PermanentRedirect,

  BadRequest,
  Unauthorized,
  PaymentRequired,
  Forbidden,
  NotFound,
  MethodNotAllowed,
  NotAcceptable,
  ProxyAuthenticationRequired,
  RequestTimeout,
  Conflict,
  Gone,
  LengthRequired,
  PreconditionFailed,
  PayloadTooLarge,
  UriTooLong,
  UnsupportedMediaType,
  RangeNotSatisfiable,
  ExpectationFailed,
  ImATeapot,
  MisdirectedRequest,
  TooEarly,
  UpgradeRequired,
  PrecoditionRequired,
  TooManyRequests,
  RequestHeaderFieldsTooLarge,
  UnavailableForLegalReasons,

  InternalServerError,
  NotImplemented,
  BadGateway,
  ServiceUnavailable,
  GatewayTimeout,
  HttpVersionNotSupported,
  VariantAlsoNegotiates,
  NotExtended,
  NetworkAuthenticationRequired,

  HttpStatus(Number)
}

let statusNum = status => {
  match (status) {
    Continue => "100",
    SwitchingProtocols => "101",

    HttpOk => "200",
    Created => "201",
    Accepted => "202",
    NonAuthoritativeInformation => "203",
    NoContent => "204",
    ResetContent => "205",
    ParialContent => "206",

    MultipleChoices => "300",
    MovedPermanently => "301",
    Found => "302",
    SeeOther => "303",
    NotModified => "304",
    TemporaryRedirect => "307",
    PermanentRedirect => "308",

    BadRequest => "400",
    Unauthorized => "401",
    PaymentRequired => "402",
    Forbidden => "403",
    NotFound => "404",
    MethodNotAllowed => "405",
    NotAcceptable => "406",
    ProxyAuthenticationRequired => "407",
    RequestTimeout => "408",
    Conflict => "409",
    Gone => "410",
    LengthRequired => "411",
    PreconditionFailed => "412",
    PayloadTooLarge => "413",
    UriTooLong => "414",
    UnsupportedMediaType => "415",
    RangeNotSatisfiable => "416",
    ExpectationFailed => "417",
    ImATeapot => "418",
    MisdirectedRequest => "421",
    TooEarly => "425",
    UpgradeRequired => "426",
    PrecoditionRequired => "428",
    TooManyRequests => "429",
    RequestHeaderFieldsTooLarge => "431",
    UnavailableForLegalReasons => "451",

    InternalServerError => "500",
    NotImplemented => "501",
    BadGateway => "502",
    ServiceUnavailable => "503",
    GatewayTimeout => "504",
    HttpVersionNotSupported => "505",
    VariantAlsoNegotiates => "506",
    NotExtended => "510",
    NetworkAuthenticationRequired => "511",
    
    HttpStatus(status) => toString(status)
  }
}

export record Response {
  status: Status,
  headers: Map.Map<String, String>,
  body: String,
}

export type ReqHandler = Request -> Response

export type Middleware = ReqHandler -> ReqHandler

export record RouteHandler {
  path: String,
  route: Route,
},
export enum Route {
  Endpoint(RequestMethod, ReqHandler),
  Router(Option<Middleware>, List<RouteHandler>)
}

// credit to https://github.com/deislabs/wagi-fileserver for the media types
let mediaTypes = Map.fromList([
  // Text formats
  ("txt", "text/plain"),
  ("md", "text/plain"),
  ("mdown", "text/plain"),
  ("htm", "text/html"),
  ("html", "text/html"),
  ("xhtml", "application/xhtml+xml"),
  ("xml", "application/xml"),
  ("css", "text/css"),
  ("ics", "text/calendar"),

  // Serialization formats
  ("json", "application/json"),
  ("jsonld", "application/ld+json"),
  ("toml", "application/toml"),
  ("yaml", "application/yaml"),

  // Applications
  // According to MSDN, prefered is text/javascript
  ("js", "text/javascript"),
  ("mjs", "text/javascript"),
  ("wasm", "application/wasm"),
  ("csv", "text/csv"),
  ("sh", "application/x-sh"),

  // Images
  ("apng", "image/apng"),
  ("avif", "image/avif"),
  ("png", "image/png"),
  ("png", "image/png"),
  ("jpg", "image/jpeg"),
  ("jpeg", "image/jpeg"),
  ("pjpeg", "image/jpeg"),
  ("pjp", "image/jpeg"),
  ("jfif", "image/jpeg"),
  ("gif", "image/gif"),
  ("tif", "image/tiff"),
  ("tiff", "image/tiff"),
  ("webp", "image/webp"),
  ("svg", "image/svg+xml"),
  ("bmp", "image/bmp"),
  ("ico", "image/vnd.microsoft.icon"),

  // Audio/Video
  ("aac", "audio/aac"),
  ("avi", "video/x-msvideo"),
  ("wav", "audio/wave"),
  ("webm", "video/webm"),
  ("mp3", "audio/mpeg"),
  ("mp4", "video/mp4"),
  ("mpeg", "video/mpeg"),
  ("oga", "audio/ogg"),
  ("ogv", "video/ogg"),
  ("ogx", "application/ogg"),
  ("ts", "video/mp2t"),

  // Compressed
  ("bz2", "application/x-bzip2"),
  ("tbz", "application/x-bzip2"),
  ("tbz2", "application/x-bzip2"),
  ("gz", "application/gzip"),
  ("rar", "application/vnd.rar"),
  ("tar", "text/x-tar"),
  ("tgz", "application/gzip"),
  ("jar", "application/java-archive"),
  ("mpkg", "application/vnd.apple.installer+xml"),
  ("zip", "application/zip"),
  ("7z", "application/x-7z-compressed"),

  // Binary
  ("azw", "application/vnd.amazon.ebook"),
  ("bin", "application/octet-stream"),
  ("doc", "application/msword"),
  (
    "docx",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  ),
  ("epub", "application/epub+zip"),
  ("odp", "application/vnd.oasis.opendocument.presentation"),
  ("ods", "application/vnd.oasis.opendocument.spreadsheet"),
  ("odt", "application/vnd.oasis.opendocument.text"),
  ("pdf", "application/pdf"),
  ("ppt", "application/vnd.ms-powerpoint"),
  (
    "pptx",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  ),
  ("rtf", "application/rtf"),
  ("vsd", "application/vnd.visio"),
  ("xls", "application/vnd.ms-excel"),
  (
    "xlsx",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  ),

  // Fonts
  ("eot", "application/vnd.ms-fontobject"),
  ("otf", "font/otf"),
  ("ttf", "font/ttf"),
  ("woff", "font/woff"),
  ("woff2", "font/woff2"),
])

let getFileType = filename => {
  match (String.lastIndexOf(".", filename)) {
    Some(i) => {
      let extension = String.slice(i + 1, String.length(filename), filename)
      Option.unwrapWithDefault("application/octet-stream", Map.get(extension, mediaTypes))
    },
    None => "application/octet-stream",
  }
}

let notFoundResponse = {
  status: NotFound,
  headers: Map.fromList([("Content-Type", "text/plain")]),
  body: "404 Not Found"
}

export let withMiddlewares = (middlewares: List<Middleware>, handler) => {
  List.reduce((h, mw) => mw(h), handler, middlewares)
}

export let text = val => {
  status: HttpOk,
  headers: Map.fromList([("Content-Type", "text/plain")]),
  body: toString(val)
}

export let file = filePath => {
  let result = File.pathOpen(File.pwdfd, [], filePath, [], [File.FdRead], [], [])

  match (result) {
    Err(_) => notFoundResponse,
    Ok(fd) => {
      let stats = Result.unwrap(File.fdFilestats(fd))
      let (contents, _) = Result.unwrap(File.fdRead(fd, Int64.toNumber(stats.size)))
      File.fdClose(fd)

      {
        status: HttpOk,
        headers: Map.fromList([("Content-Type", getFileType(filePath))]),
        body: contents
      }
    }
  }
}

export let redirect = to => {
  status: SeeOther,
  headers: Map.fromList([("Location", to)]),
  body: "Redirected to " ++ to
}

export let get = (path, handler: ReqHandler) => {
  { path, route: Endpoint(Get, handler) }
}

export let post = (path, handler: ReqHandler) => {
  { path, route: Endpoint(Post, handler) }
}

// TODO add other request methods and all/several

export let router = (path, routeHandlers: List<RouteHandler>) => {
  { path, route: Router(None, routeHandlers) }
}

export let routerWithMiddleware = (path, middleware, routeHandlers: List<RouteHandler>) => {
  { path, route: Router(Some(middleware), routeHandlers) }
}

export let log = val => {
  ignore(File.fdWrite(File.stderr, toString(val) ++ "\n"))
}

let genericErrMsg = "make sure you are running in a properly configured WAGI environment"
let failWithMsg = msg => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg
let failWithMsgWithErr = (msg, err) => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg ++ "; err " ++ toString(err)

let outputResponse = response => {
  let { headers, body, status } = response
  Map.forEach((key, val) => {
    let line = key ++ ": " ++ val
    let safeLine = Array.reduce(
      (str, c) => str ++ (if (c == '\n') "\\n" else Char.toString(c)),
      "",
      String.explode(line)
    )
    print(safeLine)
  }, headers)
  print("Status: " ++ statusNum(status) ++ "\n")
  print(body)
}

// TODO fix
let failMethodNotAllowed = reqMethod => {
  outputResponse({
    status: MethodNotAllowed,
    headers: Map.fromList([("Content-Type", "text/plain")]),
    body: "405 Method Not Allowed"
  })
  // Get
  Process.exit(1)
  Get
}

let readEnv = () => {
  let vars = match (Process.env()) {
    Ok(vars) => vars,
    Err(err) => failWithMsgWithErr("Unable to read system environment variables", err)
  }

  Map.fromArray(Array.map(var => {
    match (String.indexOf("=", var)) {
      Some(i) => {
        let varName = String.slice(0, i, var)
        let varVal = String.slice(i + 1, String.length(var), var)
        (varName, varVal)
      },
      None => failWithMsg("Error processing environment variable " ++ var)
    }
  }, vars))
}

let headerNormed = str => {
  String.implode(Array.map(c => {
    let code = Char.code(c)
    if (code >= 65 && code <= 90) {
      Char.fromCode(code + 32)
    } else if (c == '-') {
      '_'
    } else {
      c
    }
  }, String.explode(str)))
}

export let header = (key, req) => {
  let key = headerNormed(key)
  let httpVals = List.filter(((key, _)) => String.startsWith("HTTP_", key), Map.toList(req.wagiEnv))
  let headers = Map.fromList(List.map(((key, val)) => {
    let key = headerNormed(String.slice(5, String.length(key), key))
    (key, val)
  }, httpVals))
  Map.get(key, headers)
}

let readBody = wagiEnv => {
  let bodyLengthStr = match (Map.get("CONTENT_LENGTH", wagiEnv)) {
    Some(val) => val,
    None => failWithMsg("Did not find \"CONTENT_LENGTH\" in request")
  }

  let bodyLength = match (Number.parseInt(bodyLengthStr, 10)) {
    Ok(num) => num,
    Err(err) => failWithMsgWithErr("Failed to parse \"CONTENT_LENGTH\" from request to an integer", err)
  }

  match (File.fdRead(File.stdin, bodyLength)) {
    Ok((body, _)) => body,
    Err(err) => failWithMsgWithErr("Failed to read request body", err)
  }
}

let getReqMethod = wagiEnv => {
  match (Map.get("REQUEST_METHOD", wagiEnv)) {
    Some(reqMethod) => {
      match (toRequestMethod(reqMethod)) {
        Some(reqMethod) => reqMethod,
        None => failMethodNotAllowed(reqMethod)
      }
    },
    _ => failWithMsg("Did not find \"REQUEST_METHOD\" in request")
  }
}

let readArgs = () => {
  match (Process.argv()) {
    Ok(args) => {
      let [path, ...queryParamList] = Array.toList(args)
      let queryParamMap = Map.fromList(List.map(
        param => match (String.indexOf("=", param)) {
          // some query params may only have a key, set value to empty string in this case
          None => (param, ""),
          Some(i) => {
            let varName = String.slice(0, i, param)
            let varVal = String.slice(i + 1, String.length(param), param)
            (varName, varVal)
          }
        },
        queryParamList
      ))
      (path, queryParamMap)
    },
    Err(err) => failWithMsgWithErr("Unable to read system arguments", err)
  }
}

let findReqHandler = (reqMethod, path, routeHandler: RouteHandler) => {
  let pathVars = Map.make()

  let rec findReqHandlerHelper = (pathSegment, routeHandler) => {
    log("pathSeg " ++ pathSegment)
    let paramRegex = Result.unwrap(Regex.make(":\\w+"))
    let paramNames = List.map(
      (matchRes: Regex.MatchResult) => {
        let str = Option.unwrap(matchRes.group(0))
        // remove the colon at the beginning
        String.slice(1, String.length(str), str)
      },
      Regex.findAll(paramRegex, routeHandler.path)
    )
    let routeWithVarCaptures = Regex.replaceAll(paramRegex, routeHandler.path, "(\\w+)")
    log("withVarCaptures " ++ routeWithVarCaptures)
    let pathMatch = match (Regex.make(routeWithVarCaptures)) {
      Err(_) => failWithMsg("Invalid route path " ++ pathSegment),
      Ok(re) => Regex.find(re, pathSegment)
    }
    log("pathMatch " ++ toString(pathMatch))
    Option.flatMap((pathMatch: Regex.MatchResult) => {
      let (thisPathStartI, thisPathEndI) = Option.unwrap(pathMatch.groupPosition(0))
      if (thisPathStartI != 0) {
        None
      } else {
        let matchedSegment = Option.unwrap(pathMatch.group(0))
        if (pathMatch.numGroups > 1) {
          let [_, ...paramVals] = Array.toList(Array.map(grp => Option.unwrap(grp), pathMatch.allGroups()))
          List.forEach(((paramName, paramVal)) => {
            log("param " ++ paramName ++ " " ++ paramVal)
            Map.set(paramName, paramVal, pathVars)
          }, List.zip(paramNames, paramVals))
        }
        log("nummatches " ++ toString(pathMatch.numGroups))
        log("matched " ++ matchedSegment)
        let reqHandler = match (routeHandler.route) {
          Endpoint(handlerMethod, reqHandler) => if (handlerMethod == reqMethod) Some(reqHandler) else None,
          Router(middleware, routeHandlers) => {
            let nextPathSegment = String.slice(thisPathEndI, String.length(pathSegment), pathSegment)
            log("nextseg " ++ nextPathSegment)
            let reqHandler = List.reduce(
              (found, routeHandler) => match (found) {
                Some(_) => found,
                None => findReqHandlerHelper(nextPathSegment, routeHandler)
              },
              None,
              routeHandlers
            )
            let val = match ((middleware, reqHandler)) {
              (Some(middleware), Some(reqHandler)) => Some(middleware(reqHandler)),
              _ => reqHandler
            }
            val
          }
        }
        reqHandler
      }
    }, pathMatch)
  }

  (findReqHandlerHelper(path, routeHandler), pathVars)
}

export let serve = (handler: RouteHandler) => {
  let (path, query) = readArgs()
  let wagiEnv = readEnv()
  let reqMethod = getReqMethod(wagiEnv)
  let body = readBody(wagiEnv)

  let (handler, params) = findReqHandler(reqMethod, path, handler)
  log("handler " ++ toString(handler))
  let response = match (handler) {
    None => notFoundResponse,
    Some(handler) => {
      let request = {
        variables: Map.make(),
        wagiEnv,
        method: reqMethod,
        params,
        query,
        fullUrl: "",
        body
      }
      handler(request)
    }
  }
  log("response " ++ toString(response))
  outputResponse(response)
}
