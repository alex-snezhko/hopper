/**
 * @module Hopper: An HTTP microframework for the Grain programming language.
 * 
 * Version 0.1.0
 */

// this will likely get split into multiple files once Grain's module system becomes more advanced

import Option from "option"
import Result from "result"
import Number from "number"
import Map from "map"
import List from "list"
import Array from "array"
import String from "string"
import Char from "char"
import Regex from "regex"
import Int64 from "int64"
import Marshal from "marshal"
import Process from "sys/process"
import File from "sys/file"
import Time from "sys/time"

/**
 * @section Types: Type declarations included in the Hopper module.
 */

/**
 * Represents various HTTP request methods.
 */
export enum Method {
  Get,
  Post,
  Put,
  Delete,
  Head,
  Patch,
  Options,
  Trace,
  Method(String)
}

/**
 * Represents either a single value or multiple values.
 */
export enum OneOrMany<a> {
  SingleVal(a),
  MultiVal(List<a>)
}

// underscore prefix to discourage direct record field access

/**
 * Represents request-specific message data (this simply contains data
 * injected into `Message<a>` to make `Request` as `Message<RequestMsgData>`).
 * Typically you should not access the fields of this record directly.
 */
export record RequestMsgData {
  _wagiEnv: Map.Map<String, String>,
  _params: Map.Map<String, String>,
  _query: Map.Map<String, OneOrMany<String>>
}

/**
 * Represents HTTP response statuses.
 */
export enum Status {
  // 1XX
  Continue,
  SwitchingProtocols,
  // 2XX
  HttpOk,
  Created,
  Accepted,
  NonAuthoritativeInformation,
  NoContent,
  ResetContent,
  ParialContent,
  // 3XX
  MultipleChoices,
  MovedPermanently,
  Found,
  SeeOther,
  NotModified,
  TemporaryRedirect,
  PermanentRedirect,
  // 4XX
  BadRequest,
  Unauthorized,
  PaymentRequired,
  Forbidden,
  NotFound,
  MethodNotAllowed,
  NotAcceptable,
  ProxyAuthenticationRequired,
  RequestTimeout,
  Conflict,
  Gone,
  LengthRequired,
  PreconditionFailed,
  PayloadTooLarge,
  UriTooLong,
  UnsupportedMediaType,
  RangeNotSatisfiable,
  ExpectationFailed,
  ImATeapot,
  MisdirectedRequest,
  TooEarly,
  UpgradeRequired,
  PrecoditionRequired,
  TooManyRequests,
  RequestHeaderFieldsTooLarge,
  UnavailableForLegalReasons,
  // 5XX
  InternalServerError,
  NotImplemented,
  BadGateway,
  ServiceUnavailable,
  GatewayTimeout,
  HttpVersionNotSupported,
  VariantAlsoNegotiates,
  NotExtended,
  NetworkAuthenticationRequired,
  // arbitrary status
  Status(Number)
}


/**
 * Represents response-specific message data (this simply contains data
 * injected into `Message<a>` to make `Response` as `Message<ResponseMsgData>`).
 * Typically you should not access the fields of this record directly.
 */
export record ResponseMsgData {
  _status: Status
}

/**
 * Opaque polymorphic representation of an HTTP message (concretely instanced
 * by `Request` and `Response` types). Typically you should not access the
 * fields of this record directly.
 */
export record Message<a> {
  _message: a,
  _headers: Map.Map<String, String>,
  _body: String,
  _variables: Map.Map<String, Bytes>,
}

/**
 * Represents an HTTP request.
 */
export type Request = Message<RequestMsgData>

/**
 * Represents an HTTP response.
 */
export type Response = Message<ResponseMsgData>

/**
 * Represents an HTTP request handler which processes a request and returns a response.
 */
export type RequestHandler = Request -> Response

/**
 * Represents an HTTP middleware, which sits between the client and base request handler.
 */
export type Middleware = RequestHandler -> RequestHandler

// test-export
export enum RequestMethods {
  Methods(List<Method>),
  All
}

record Route {
  path: String,
  routeHandler: RouteHandler,
},
enum RouteHandler {
  Endpoint(RequestMethods, RequestHandler),
  Scope(Middleware, List<Route>)
}

/**
 * Represents data for a file for `multipart/form-data` requests.
 */
export record FilePartData {
  filename: String,
  contentType: String,
  content: String
}

/**
 * Represents data for `multipart/form-data` requests.
 */
export enum Part {
  FilePart(FilePartData),
  TextPart(String)
}

/**
 * Represents possible errors encountered while parsing form bodies.
 */
export enum FormError {
  ContentTypeNotAllowed,
  InvalidFormData(String),
}

/**
 * Represents possible `Err` reasons for why a variable's value was not read.
 * 
 * `NotSet` indicates that a variable with the given name does not exist
 * 
 * `DeserializationError` indicates that the variable was unable to be
 * deserialized properly. The attached `String` gives the error reason
 */
export enum GetVariableError {
  NotSet,
  DeserializationError(String),
}

/**
 * Represents the result of fetching a message variable. A `Result` with an
 * `Ok` variant containing the value or `GetVariableError` `Err` variant.
 */
export type Variable<a> = Result<a, GetVariableError>

/**
 * @section Values: Functions included in the Hopper module.
 */

/**
 * Writes a message to the WAGI log file.
 * 
 * @param val: The value to write out to the log
 */
export let log = val => {
  ignore(File.fdWrite(File.stderr, toString(val) ++ "\n"))
}

let methodPairs = [
  (Get, "GET"),
  (Post, "POST"),
  (Put, "PUT"),
  (Delete, "DELETE"),
  (Head, "HEAD"),
  (Patch, "PATCH"),
  (Options, "OPTIONS"),
  (Trace, "TRACE"),
]

let methodToStringMap = Map.fromList(methodPairs)
let stringToMethodMap = Map.fromList(List.map(((a, b)) => (b, a), methodPairs))

/**
 * Converts a string to an HTTP `Method`.
 * 
 * @param str: The string to convert to a `Method`
 * @returns A `Method` representing the string
 * 
 * @example Hopper.stringToMethod("GET") // Method.Get
 */
export let stringToMethod = str => {
  match (Map.get(str, stringToMethodMap)) {
    Some(method) => method,
    None => Method(str)
  }
}

/**
 * Converts a `Method` to a string describing the method.
 * 
 * @param method: `Method` to stringify
 * @returns A string representing the `Method`
 */
export let methodToString = method => {
  match (method) {
    Method(str) => str,
    _ => Option.unwrap(Map.get(method, methodToStringMap))
  }
}

let statusPairs = [
  (Continue, 100),
  (SwitchingProtocols, 101),

  (HttpOk, 200),
  (Created, 201),
  (Accepted, 202),
  (NonAuthoritativeInformation, 203),
  (NoContent, 204),
  (ResetContent, 205),
  (ParialContent, 206),

  (MultipleChoices, 300),
  (MovedPermanently, 301),
  (Found, 302),
  (SeeOther, 303),
  (NotModified, 304),
  (TemporaryRedirect, 307),
  (PermanentRedirect, 308),

  (BadRequest, 400),
  (Unauthorized, 401),
  (PaymentRequired, 402),
  (Forbidden, 403),
  (NotFound, 404),
  (MethodNotAllowed, 405),
  (NotAcceptable, 406),
  (ProxyAuthenticationRequired, 407),
  (RequestTimeout, 408),
  (Conflict, 409),
  (Gone, 410),
  (LengthRequired, 411),
  (PreconditionFailed, 412),
  (PayloadTooLarge, 413),
  (UriTooLong, 414),
  (UnsupportedMediaType, 415),
  (RangeNotSatisfiable, 416),
  (ExpectationFailed, 417),
  (ImATeapot, 418),
  (MisdirectedRequest, 421),
  (TooEarly, 425),
  (UpgradeRequired, 426),
  (PrecoditionRequired, 428),
  (TooManyRequests, 429),
  (RequestHeaderFieldsTooLarge, 431),
  (UnavailableForLegalReasons, 451),

  (InternalServerError, 500),
  (NotImplemented, 501),
  (BadGateway, 502),
  (ServiceUnavailable, 503),
  (GatewayTimeout, 504),
  (HttpVersionNotSupported, 505),
  (VariantAlsoNegotiates, 506),
  (NotExtended, 510),
  (NetworkAuthenticationRequired, 511),
]

let statusToCodeMap = Map.fromList(statusPairs)
let codeToStatusMap = Map.fromList(List.map(((a, b)) => (b, a), statusPairs))

/**
 * Converts a status code to its corresponding status.
 * 
 * @param status: A status code to convert to a `Status`
 * @returns A status representing the given code
 */
export let codeToStatus = code => {
  match (Map.get(code, codeToStatusMap)) {
    Some(status) => status,
    _ => Status(code)
  }
}

/**
 * Converts a response status to its corresponding status code.
 * 
 * @param status: A `Status` to get the status code of
 * @returns A status code for the response status
 */
export let statusToCode = status => {
  match (status) {
    Status(status) => status,
    _ => Option.unwrap(Map.get(status, statusToCodeMap))
  }
}

let isStatusType = beginRange => status => {
  let code = statusToCode(status)
  let endRange = beginRange + 100
  code >= beginRange && code < endRange
}

/**
 * Determines if an HTTP status is informational i.e. has a 1XX code.
 * 
 * @param status: The status to examine
 * @returns `true` if the status has a 1XX status code or `false` otherwise
 */
export let isInformationalStatus = isStatusType(100)

/**
 * Determines if an HTTP status is successful i.e. has a 2XX code.
 * 
 * @param status: The status to examine
 * @returns `true` if the status has a 2XX status code or `false` otherwise
 */
export let isSuccessfulStatus = isStatusType(200)

/**
 * Determines if an HTTP status is a redirection i.e. has a 3XX code.
 * 
 * @param status: The status to examine
 * @returns `true` if the status has a 3XX status code or `false` otherwise
 */
export let isRedirectionStatus = isStatusType(300)

/**
 * Determines if an HTTP status is a client error i.e. has a 4XX code.
 * 
 * @param status: The status to examine
 * @returns `true` if the status has a 4XX status code or `false` otherwise
 */
export let isClientErrorStatus = isStatusType(400)

/**
 * Determines if an HTTP status is a server error i.e. has a 5XX code.
 * 
 * @param status: The status to examine
 * @returns `true` if the status has a 5XX status code or `false` otherwise
 */
export let isServerErrorStatus = isStatusType(500)

// credit to https://github.com/deislabs/wagi-fileserver for the media types
let mediaTypes = Map.fromList([
  // Text formats
  ("txt", "text/plain"),
  ("md", "text/plain"),
  ("mdown", "text/plain"),
  ("htm", "text/html"),
  ("html", "text/html"),
  ("xhtml", "application/xhtml+xml"),
  ("xml", "application/xml"),
  ("css", "text/css"),
  ("ics", "text/calendar"),

  // Serialization formats
  ("json", "application/json"),
  ("jsonld", "application/ld+json"),
  ("toml", "application/toml"),
  ("yaml", "application/yaml"),

  // Applications
  // According to MSDN, prefered is text/javascript
  ("js", "text/javascript"),
  ("mjs", "text/javascript"),
  ("wasm", "application/wasm"),
  ("csv", "text/csv"),
  ("sh", "application/x-sh"),

  // Images
  ("apng", "image/apng"),
  ("avif", "image/avif"),
  ("png", "image/png"),
  ("png", "image/png"),
  ("jpg", "image/jpeg"),
  ("jpeg", "image/jpeg"),
  ("pjpeg", "image/jpeg"),
  ("pjp", "image/jpeg"),
  ("jfif", "image/jpeg"),
  ("gif", "image/gif"),
  ("tif", "image/tiff"),
  ("tiff", "image/tiff"),
  ("webp", "image/webp"),
  ("svg", "image/svg+xml"),
  ("bmp", "image/bmp"),
  ("ico", "image/vnd.microsoft.icon"),

  // Audio/Video
  ("aac", "audio/aac"),
  ("avi", "video/x-msvideo"),
  ("wav", "audio/wave"),
  ("webm", "video/webm"),
  ("mp3", "audio/mpeg"),
  ("mp4", "video/mp4"),
  ("mpeg", "video/mpeg"),
  ("oga", "audio/ogg"),
  ("ogv", "video/ogg"),
  ("ogx", "application/ogg"),
  ("ts", "video/mp2t"),

  // Compressed
  ("bz2", "application/x-bzip2"),
  ("tbz", "application/x-bzip2"),
  ("tbz2", "application/x-bzip2"),
  ("gz", "application/gzip"),
  ("rar", "application/vnd.rar"),
  ("tar", "text/x-tar"),
  ("tgz", "application/gzip"),
  ("jar", "application/java-archive"),
  ("mpkg", "application/vnd.apple.installer+xml"),
  ("zip", "application/zip"),
  ("7z", "application/x-7z-compressed"),

  // Binary
  ("azw", "application/vnd.amazon.ebook"),
  ("bin", "application/octet-stream"),
  ("doc", "application/msword"),
  (
    "docx",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  ),
  ("epub", "application/epub+zip"),
  ("odp", "application/vnd.oasis.opendocument.presentation"),
  ("ods", "application/vnd.oasis.opendocument.spreadsheet"),
  ("odt", "application/vnd.oasis.opendocument.text"),
  ("pdf", "application/pdf"),
  ("ppt", "application/vnd.ms-powerpoint"),
  (
    "pptx",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  ),
  ("rtf", "application/rtf"),
  ("vsd", "application/vnd.visio"),
  ("xls", "application/vnd.ms-excel"),
  (
    "xlsx",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  ),

  // Fonts
  ("eot", "application/vnd.ms-fontobject"),
  ("otf", "font/otf"),
  ("ttf", "font/ttf"),
  ("woff", "font/woff"),
  ("woff2", "font/woff2"),
])

/**
 * Guesses the MIME type of a media file by its filename extension.
 * 
 * @param fileName: The filename to guess the MIME type of
 * @returns A MIME type string for the filename
 */
export let guessMimeType = fileName => {
  match (String.lastIndexOf(".", fileName)) {
    Some(i) => {
      let extension = String.slice(i + 1, String.length(fileName), fileName)
      Option.unwrapWithDefault("application/octet-stream", Map.get(extension, mediaTypes))
    },
    None => "application/octet-stream",
  }
}

/**
 * Utility function to combine multiple middlewares into one function.
 * 
 * @param mws: The middlewares to combine
 * @returns A single middleware function, chaining the first middleware in the list down to the last
 */
export let middlewares: List<Middleware> -> Middleware = mws => handler => {
  List.reduceRight((mw, handler) => mw(handler), handler, mws)
}

// TODO add cookies once cryptography added to stdlib

/**
 * Creates a new `Response` with a status, headers, and body.
 * 
 * @param status: The desired HTTP status
 * @param headers: The desired HTTP headers
 * @param body: The body string to create the `Response` with
 * @returns A new `Response` with the given values
 */
export let response = (status, headers, body) => {
  { _message: { _status: status, }, _variables: Map.make(), _headers: headers, _body: body }: Response
}

/**
 * Creates a new OK `Response` with a text body and `"text/plain"` Content-Type.
 * 
 * @param body: The text body to create the `Response` with
 * @returns A new text `Response`
 */
export let text = body => response(HttpOk, Map.fromList([("Content-Type", "text/plain")]), body)

/**
 * Creates a new OK `Response` with a JSON string body and `"application/json"` Content-Type.
 * 
 * Note: the argument type will likely be changed to a more friendly JSON
 * representation once https://github.com/grain-lang/grain/pull/1133 gets
 * merged.
 * 
 * @param body: The JSON body to create the `Response` with
 * @returns A new JSON `Response`
 */
export let json = body => response(HttpOk, Map.fromList([("Content-Type", "application/json")]), body)

/**
 * Creates a new OK `Response` with the specified content type.
 * 
 * @param contentType: The Content-Type to set for the `Response`
 * @param body: The body of the response
 * @returns A new `Response` with the given content type
 */
export let contentType = (contentType, body) => response(HttpOk, Map.fromList([("Content-Type", contentType)]), body)

/**
 * Creates a new `Response` from an existing response, but with the response status code changed.
 * 
 * @param status: The desired HTTP status
 * @param res: The base response
 * @returns A new `Response` with the desired HTTP status
 */
export let newStatus = (status: Status, res: Response) => {
  let { _headers, _body, _ } = res
  response(status, _headers, _body)
}

let notFound = response(NotFound, Map.fromList([("Content-Type", "text/plain")]), "Requested URL not found")
let methodNotSupported = supportedMethods => {
  let allowed = List.join(", ", List.map(methodToString, supportedMethods))
  response(
    MethodNotAllowed,
    Map.fromList([("Content-Type", "text/plain"), ("Allow", allowed)]),
    "Method not allowed for this URL"
  )
}

/**
 * Creates a new `Response` from a static file on the server at the given path.
 * 
 * @param filePath: The path of the file to search for on the server
 * @returns A new OK `Response` if the file is found, or a "Not Found" reponse otherwise
 */
export let file = filePath => {
  let result = File.pathOpen(File.pwdfd, [], filePath, [], [File.FdFilestats, File.FdRead], [], [])

  match (result) {
    Err(_) => response(NotFound, Map.fromList([("Content-Type", "text/plain")]), "File Not Found"),
    Ok(fd) => {
      let stats = Result.unwrap(File.fdFilestats(fd))
      let (contents, _) = Result.unwrap(File.fdRead(fd, Int64.toNumber(stats.size)))
      File.fdClose(fd)

      response(HttpOk, Map.fromList([("Content-Type", guessMimeType(filePath))]), contents)
    }
  }
}

/**
 * Creates a new redirection `Response` to another route on the server.
 * 
 * @param path: The local path to redirect to
 * @param req: The incoming `Request`
 * @returns A new redirection `Response` with status code "302 Found"
 */
export let redirectLocal = (path, req: Request) => {
  let item = key => Option.unwrap(Map.get(key, req._message._wagiEnv))
  let protocol = if (String.startsWith("https://", item("X_FULL_URL"))) "https://" else "http://"
  let baseUrl = protocol ++ item("SERVER_NAME") ++ ":" ++ item("SERVER_PORT")
  response(Found, Map.fromList([("Location", baseUrl ++ path)]), "")
}

/**
 * Creates a new redirection `Response` to an arbitrary URL.
 * 
 * @param url: The URL to redirect to
 * @returns A new redirection `Response` with status code "302 Found"
 */
export let redirectExternal = url => response(Found, Map.fromList([("Location", url)]), "")

let createRoute = (path, methods, handler) => {
  { path, routeHandler: Endpoint(methods, handler) }
}

/**
 * Creates a new `Route` for handling GET requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling GET requests at a path
 */
export let get = (path, handler) => {
  createRoute(path, Methods([Get]), handler)
}

/**
 * Creates a new `Route` for handling POST requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling POST requests at a path
 */
export let post = (path, handler) => {
  createRoute(path, Methods([Post]), handler)
}

/**
 * Creates a new `Route` for handling PUT requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling PUT requests at a path
 */
export let put = (path, handler) => {
  createRoute(path, Methods([Put]), handler)
}

/**
 * Creates a new `Route` for handling DELETE requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling DELETE requests at a path
 */
export let delete = (path, handler) => {
  createRoute(path, Methods([Delete]), handler)
}

/**
 * Creates a new `Route` for handling HEAD requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling HEAD requests at a path
 */
export let head = (path, handler) => {
  createRoute(path, Methods([Head]), handler)
}

/**
 * Creates a new `Route` for handling PATCH requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling PATCH requests at a path
 */
export let patch = (path, handler) => {
  createRoute(path, Methods([Patch]), handler)
}

/**
 * Creates a new `Route` for handling OPTIONS requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling OPTIONS requests at a path
 */
export let options = (path, handler) => {
  createRoute(path, Methods([Options]), handler)
}

/**
 * Creates a new `Route` for handling TRACE requests at a path.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling TRACE requests at a path
 */
export let trace = (path, handler) => {
  createRoute(path, Methods([Trace]), handler)
}

/**
 * Creates a new `Route` for handling requests at a path.
 * 
 * @param method: The HTTP method the route will handle
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling requests at a path
 */
export let route = (method, path, handler) => {
  createRoute(path, Methods([method]), handler)
}

/**
 * Creates a new `Route` for handling requests at a path with multiple allowed HTTP methods.
 * 
 * @param methods: The HTTP methods the route will handle
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling requests at a path
 */
export let methodsRoute = (methods, path, handler) => {
  createRoute(path, Methods(methods), handler)
}

/**
 * Creates a new `Route` for handling requests at a path for all HTTP methods.
 * 
 * @param path: The relative path the request handler will reside on
 * @param handler: The `RequestHandler` responsible for handling the request
 * @returns A new `Route` handling requests at a path
 */
export let all = (path, handler) => {
  createRoute(path, All, handler)
}

/**
 * Creates a new `Route` composed of multiple sub-routes defined relative to
 * the path given. A middleware is also applied to all requests in the scope.
 * 
 * @param path: The relative path the request handler will reside on
 * @param middleware: The middleware to apply to the routes in the scope
 * @param routes: The `Route`s composing the scope
 * @returns A new `Route` handling requests rooted from the path
 */
export let scopeWithMiddleware = (path, middleware, routes) => {
  { path, routeHandler: Scope(middleware, routes) }
}

/**
 * Creates a new `Route` composed of multiple sub-routes defined relative to the path given.
 * 
 * @param path: The relative path the request handler will reside on
 * @param routes: The `Route`s composing the scope
 * @returns A new `Route` handling requests rooted from the path
 */
export let scope = (path, routes) => {
  scopeWithMiddleware(path, identity, routes)
}

let genericErrMsg = "make sure you are running in a properly configured WAGI environment"
let failWithMsg = msg => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg
let failWithMsgWithErr = (msg, err) => fail "ERROR " ++ msg ++ "; " ++ genericErrMsg ++ "; err " ++ toString(err)

let outputResponse = (res: Response) => {
  let { _headers, _body, _message: { _status }, _ } = res
  // script must specify Content-Type per CGI v1.1 spec, so default to
  // application/octet-stream if one was not given
  Map.update("Content-Type", val => match (val) {
    None => Some("application/octet-stream"),
    _ => val
  }, _headers)
  Map.set("Status", toString(statusToCode(_status)), _headers)

  let safeHeaders = Map.fromList(List.map(((key, val)) => {
    // remove any newline characters from headers because that will cause
    // header values to be written to body (since a blank line separates
    // headers from body in CGI spec)
    let makeSafe = str => Array.reduce(
      (str, c) => str ++ (if (c == '\n') "\\n" else Char.toString(c)),
      "",
      String.explode(str)
    )
    (makeSafe(key), makeSafe(val))
  }, Map.toList(_headers)))

  // redirects should not specify additional headers per CGI spec
  match (Map.get("Location", safeHeaders)) {
    Some(location) => print("Location: " ++ location ++ "\n\n"),
    None => {
      Map.forEach((key, val) => print(key ++ ": " ++ val), safeHeaders)
      // empty line separates headers from body per CGI spec
      print("")
      print(_body)
    }
  }
}

let getWagiEnv = () => {
  let vars = match (Process.env()) {
    Ok(vars) => vars,
    Err(err) => failWithMsgWithErr("Unable to read system environment variables", err)
  }

  Map.fromArray(Array.map(var => {
    match (String.indexOf("=", var)) {
      Some(i) => {
        let varName = String.slice(0, i, var)
        let varVal = String.slice(i + 1, String.length(var), var)
        (varName, varVal)
      },
      None => failWithMsg("Error processing environment variable " ++ var)
    }
  }, vars))
}

let getHeaders = wagiEnv => {
  let headerEntries = List.filter(((key, _)) => String.startsWith("HTTP_", key), Map.toList(wagiEnv))
  let headerKeyVals = List.map(((key, val)) => {
    let key = String.slice(5, String.length(key), key)
    (key, val)
  }, headerEntries)
  Map.fromList(headerKeyVals)
}

let getReqMethod = wagiEnv => {
  match (Map.get("REQUEST_METHOD", wagiEnv)) {
    Some(reqMethod) => stringToMethod(reqMethod),
    _ => failWithMsg("Did not find \"REQUEST_METHOD\" in request")
  }
}

let toLower = str => {
  String.implode(Array.map(c => {
    let code = Char.code(c)
    if (code >= 65 && code <= 90) Char.fromCode(code + 32) else c
  }, String.explode(str)))
}

let headerNormed = str => {
  String.implode(Array.map(
    c => if (c == '_') '-' else c,
    String.explode(toLower(str))
  ))
}

/**
 * Fetches a URL query parameter with the given name.
 * 
 * @param key: The name of the parameter to fetch the value of
 * @param req: The request to fetch the query parameter from
 * @returns The value of the query parameter with the given name
 */
export let query = (key, req: Request) => {
  Map.get(key, req._message._query)
}

/**
 * Fetches all URL query parameters.
 * 
 * @param req: The request to fetch the query parameters from
 * @returns All query parameters given
 */
export let queries = (req: Request) => {
  req._message._query
}

let getPath = wagiEnv => {
  match (Map.get("PATH_INFO", wagiEnv)) {
    Some(val) => val,
    None => failWithMsg("Did not find \"PATH_INFO\" in environment")
  }
}

/**
 * Fetches the full path from the requested URL.
 * 
 * @param req: The request to examine
 * @returns The full path requested
 */
export let path = (req: Request) => {
  getPath(req._message._wagiEnv)
}

/**
 * Fetches a path parameter from the request.
 * 
 * @param key: The path parameter to fetch
 * @param req: The request to examine
 * @returns The path parameter requested
 */
export let param = (key, req: Request) => {
  Option.expect("URL path param " ++ key ++ " expected to exist on request but did not", Map.get(key, req._message._params))
}

/**
 * Fetches the HTTP method of the request.
 * 
 * @param req: The request to examine
 * @returns The HTTP method of the request.
 */
export let method = (req: Request) => {
  getReqMethod(req._message._wagiEnv)
}

/**
 * Fetches the HTTP response status of a response.
 * 
 * @param res: The response to examine
 * @returns The status of the response
 */
export let status = (res: Response) => {
  res._message._status
}

/**
 * Fetches a header from the message.
 * 
 * @param key: The header to request
 * @param msg: The request or response to examine
 * @returns The header value requested
 */
export let header = (key, msg) => {
  let key = headerNormed(key)
  let header = List.find(
    ((headerKey, val)) => headerNormed(headerKey) == key,
    Map.toList(msg._headers)
  )
  match (header) {
    Some((_, val)) => Some(val),
    None => None
  }
}

/**
 * Fetches headers on a message.
 * 
 * @param msg: The request or response to examine
 * @returns The headers on the request or response, with header names all in lowercase
 */
export let headers = msg => {
  Map.fromList(List.map(((key, val)) => (headerNormed(key), val), Map.toList(msg._headers)))
}

/**
 * Fetches the message body as a string.
 * 
 * @param msg: The request or response to examine
 * @returns The body as a string
 */
export let body = msg => {
  msg._body
}

/**
 * Sets a variable on a message to a new arbitrary value.
 * 
 * @param key: The variable to set
 * @param value: The new value to give the variable
 * @param msg: The message to attach the variable to
 */
export let setVariable = (key, value, msg) => {
  Map.set(key, Marshal.marshal(value), msg._variables)
}

/**
 * Fetches the value of a variable set on a message. The result of this
 * function should be explicitly typed.
 * 
 * @param key: The variable to fetch
 * @param msg: The message to inspect
 * @returns The value of the variable requested
 */
export let variable = (key, msg) => {
  match (Map.get(key, msg._variables)) {
    Some(val) => {
      match (Marshal.unmarshal(val)) {
        Ok(val) => Ok(val),
        Err(err) => Err(DeserializationError(err)),
      }
    },
    None => Err(NotSet)
  }: Variable<a>
}

let parseUrlEncoded = parts => {
  List.map(part => {
    match (String.indexOf("=", part)) {
      // some parts may only have a key, set value to empty string in this case
      None => (part, ""),
      Some(i) => {
        let name = String.slice(0, i, part)
        let val = String.slice(i + 1, String.length(part), part)
        (name, val)
      }
    }
  }, parts)
}

let combineToMapSharedKeys = list => {
  let valMap = Map.make()
  List.forEach(((key, val)) => {
    match (Map.get(key, valMap)) {
      None => Map.set(key, SingleVal(val), valMap),
      Some(SingleVal(currVal)) => Map.set(key, MultiVal([currVal, val]), valMap),
      Some(MultiVal(currVals)) => Map.set(key, MultiVal(List.append(currVals, [val])), valMap)
    }
  }, list)
  valMap
}

/**
 * Parses an HTTP request body with URL-encoded form data into a `Map` mapping
 * form item names to their values. The keys/values are expected to be
 * URL-encoded with `Content-Type: x-www-form-urlencoded`
 * 
 * @param req: The incoming `Request`
 * @returns A `Map` mapping form item names to their values
 */
export let urlencodedFormBody = req => {
  match (header("Content-Type", req)) {
    Some(t) when String.startsWith("application/x-www-form-urlencoded", t) => {
      let parts = Array.toList(String.split("&", req._body))
      let urlEncodedItems = parseUrlEncoded(parts)
      Ok(combineToMapSharedKeys(urlEncodedItems))
    },
    _ => Err(ContentTypeNotAllowed)
  }
}

let partContentDisposition = headers => {
  let regex = Result.unwrap(Regex.make("^content-disposition:\\s*form-data;"))
  let contentDispositionLine = List.find(
    line => Regex.isMatch(regex, toLower(line)),
    headers
  )
  match (contentDispositionLine) {
    None => Err(InvalidFormData("Part missing Content-Disposition: form-data header")),
    Some(contentDispositionLine) => {
      // TODO can make more robust in the future
      let nameRegex = Result.unwrap(Regex.make("name=\"([^\"]+)\""))
      let filenameRegex = Result.unwrap(Regex.make("filename=\"([^\"]+)\""))
      match (Regex.find(nameRegex, contentDispositionLine)) {
        None => Err(InvalidFormData("Part missing name in Content-Disposition header")),
        Some(reMatch) => {
          let name = Option.unwrap(reMatch.group(1))
          let filename = Option.map(
            (reMatch: Regex.MatchResult) => Option.unwrap(reMatch.group(1)),
            Regex.find(filenameRegex, contentDispositionLine)
          )
          Ok((name, filename))
        }
      }
    }
  }
}

let partContentType = (headers, filename) => {
  let contentTypeLine = List.find(
    line => String.startsWith("content-type:", toLower(line)),
    headers
  )
  match (contentTypeLine) {
    Some(line) => String.trim(String.slice(String.length("content-type:"), String.length(line), line)),
    None => guessMimeType(filename)
  }
}

let readMultipart = (body, boundary) => {
  let lines = Array.toList(String.split("\n", body))
  // first line will be boundary
  let [_, ...lines] = lines
  let lines = List.takeWhile(line => line != "--" ++ boundary ++ "--", lines)
  let parts = List.reduceRight(
    (line, parts) => {
      if (line == "--" ++ boundary) {
        [[], ...parts]
      } else {
        let [partLines, ...rest] = parts
        [[line, ...partLines], ...rest]
      }
    },
    [[]],
    lines
  )
  let multipartNameVals = List.reduceRight(
    (partLines, multipartNameVals) => {
      match (multipartNameVals) {
        Err(err) => Err(err),
        Ok(multipartNameVals) => {
          let lineEmpty = line => String.trim(line) == ""
          let headers = List.takeWhile(line => !lineEmpty(line), partLines)

          match (partContentDisposition(headers)) {
            Err(err) => Err(err),
            Ok((name, filename)) => {
              let body = List.dropWhile(lineEmpty, List.dropWhile(line => !lineEmpty(line), partLines))
              let bodyStr = List.join("\n", body)
              let val = match (filename) {
                Some(filename) => {
                  let contentType = partContentType(headers, filename)
                  FilePart({ filename, contentType, content: bodyStr })
                },
                None => TextPart(bodyStr)
              }
              Ok([(name, val), ...multipartNameVals])
            }
          }
        }
      }
    },
    Ok([]),
    parts
  )
  Result.map(combineToMapSharedKeys, multipartNameVals)
}

/**
 * Parses an HTTP request body with multipart form data into a `Map` mapping
 * form item names to their values. The request should have
 * `Content-Type: multipart/form-data`
 * 
 * @param req: The incoming `Request`
 * @returns A `Map` mapping form item names to their values
 */
export let multipartFormBody = req => {
  match (header("Content-Type", req)) {
    Some(val) when String.startsWith("multipart/form-data;", val) => {
      let boundary = String.trim(String.slice(String.length("multipart/form-data;"), String.length(val), val))
      if (String.startsWith("boundary=", boundary)) {
        let boundaryVal = String.slice(String.length("boundary="), String.length(boundary), boundary)
        readMultipart(req._body, boundaryVal)
      } else {
        Err(InvalidFormData("Form data missing boundary"))
      }
    },
    _ => Err(ContentTypeNotAllowed)
  }
}

let getBody = wagiEnv => {
  let bodyLengthStr = match (Map.get("CONTENT_LENGTH", wagiEnv)) {
    Some(val) => val,
    None => failWithMsg("Did not find \"CONTENT_LENGTH\" in environment")
  }

  let bodyLength = match (Number.parseInt(bodyLengthStr, 10)) {
    Ok(num) => num,
    Err(err) => failWithMsgWithErr("Failed to parse \"CONTENT_LENGTH\" from environment to an integer", err)
  }

  match (File.fdRead(File.stdin, bodyLength)) {
    Ok((body, _)) => body,
    Err(err) => failWithMsgWithErr("Failed to read request body", err)
  }
}

let getQueryMap = () => {
  match (Process.argv()) {
    Ok(args) => {
      let [_, ...queryParamList] = Array.toList(args)
      let urlEncodedItems = parseUrlEncoded(queryParamList)
      combineToMapSharedKeys(urlEncodedItems)
    },
    Err(err) => failWithMsgWithErr("Unable to read system arguments", err)
  }
}

// TODO allow escaping of <
// a bit of a hack to not capture regex groups specified in route.
// if something is going wrong with matching patterns it may be due to this
let captureGroupRegex = Result.unwrap(Regex.make("(?<!\\\\)\\((?!\\?)"))
let replaceWithCapturesRegex = Result.unwrap(Regex.make("<\\w+\\(\\?:(.+?)\\)>"))
let paramRegex = Result.unwrap(Regex.make("<\\w+>"))
let customParamRegex = Result.unwrap(Regex.make("<\\w+\\((.+?)\\)>"))
let paramNameRegex = Result.unwrap(Regex.make("<(\\w+)>"))
let customParamNameRegex = Result.unwrap(Regex.make("<(\\w+)\\(.+?\\)>"))
// lookbehind to prevent single slash character from being matched
// let slashAtEndRegex = Result.unwrap(Regex.make("(?<=.)/$"))
let slashAtEndRegex = Result.unwrap(Regex.make("/$"))

// test-export
export let preprocessRouteSegmentRegex = routeSegment => {
  let preprocessed = List.reduce(
    (str, (regex, replaceWith)) => {
      Regex.replaceAll(regex, str, replaceWith)
    },
    routeSegment,
    [
      (captureGroupRegex, "(?:"),
      (replaceWithCapturesRegex, "($1)"),
      (customParamRegex, "($1)"),
      (paramRegex, "(\\w+)"),
      (slashAtEndRegex, ""),
    ]
  )
  // should probably replace with regex once
  // https://github.com/grain-lang/grain/issues/1431 is fixed
  (if (!String.startsWith("/", preprocessed)) "/" else "") ++ preprocessed
}

enum RouteMatchStatus {
  RouteNotFound,
  MethodNotSupported(List<Method>),
  RouteFound(RequestHandler, Map.Map<String, String>)
}

// use a "precedence" value to keep track of best route found e.g. to
// make a route with wrong method override one not found at all
let isBetterRouteMatch = (firstRms, secondRms) => {
  let precedence = rms => match (rms) {
    RouteNotFound => 1,
    MethodNotSupported(_) => 2,
    RouteFound(_, _) => 3
  }
  precedence(firstRms) > precedence(secondRms)
}

let getPathParamNames = routePath => {
  let paramNameRegexes = List.append(
    Regex.findAll(paramNameRegex, routePath),
    Regex.findAll(customParamNameRegex, routePath)
  )
  let paramNames = List.map(
    (matchRes: Regex.MatchResult) => Option.unwrap(matchRes.group(1)),
    paramNameRegexes
  )
  paramNames
}

// test-export
export let rec allReqHandlers = route => {
  let pathParamNames = getPathParamNames(route.path)
  let path = preprocessRouteSegmentRegex(route.path)
  match (route.routeHandler) {
    Endpoint(handlerMethods, reqHandler) => {
      [(path, pathParamNames, handlerMethods, reqHandler)]
    },
    Scope(middleware, routes) => {
      List.flatMap(subRoute => {
        List.map(((subPath, subPathParamNames, handlerMethods, reqHandler)) => {
          let basePath = if (path == "/") "" else path
          (
            basePath ++ subPath,
            List.append(pathParamNames, subPathParamNames),
            handlerMethods,
            middleware(reqHandler)
          )
        }, allReqHandlers(subRoute))
      }, routes)
    }
  }
}

// test-export
export let findReqHandler = (reqMethod, reqPath, route) => {
  let reqPath = if (reqPath != "/") Regex.replace(slashAtEndRegex, reqPath, "") else "/"

  let handlers = allReqHandlers(route)

  let bestMatch = List.reduce(
    (bestMatch, (routePath, paramNames, handlerMethods, reqHandler)) => {
      let routeRegex = Result.expect(
        "Invalid route path regular expression " ++ routePath,
        Regex.make("^" ++ routePath ++ "$")
      )
      let thisMatch = match (Regex.find(routeRegex, reqPath)) {
        None => RouteNotFound,
        Some(pathMatch) => {
          match (handlerMethods) {
            Methods(methods) when !List.contains(reqMethod, methods) => MethodNotSupported(methods),
            _ => {
              let [_, ...paramVals] = Array.toList(
                Array.map(Option.unwrap, pathMatch.allGroups())
              )
              let pathParams = Map.fromList(List.zip(paramNames, paramVals))
              RouteFound(reqHandler, pathParams)
            }
          }
        }
      }
      match ((bestMatch, thisMatch)) {
        (MethodNotSupported(bestMethods), MethodNotSupported(thisMethods)) => {
          MethodNotSupported(List.unique(List.append(bestMethods, thisMethods)))
        },
        // overwrite matched route handler if it is better than
        // the best one found so far
        _ when isBetterRouteMatch(thisMatch, bestMatch) => thisMatch,
        _ => bestMatch,
      }
    },
    RouteNotFound,
    handlers
  )

  let (reqHandler, pathParams) = match (bestMatch) {
    RouteNotFound => (req => notFound, Map.make()),
    MethodNotSupported(supported) => (req => methodNotSupported(supported), Map.make()),
    RouteFound(reqHandler, pathParams) => (reqHandler, pathParams)
  }
  (reqHandler, pathParams)
}

/**
 * Entry point for creating a server, taking a list of routes and a middleware
 * to apply to all routes.
 * 
 * @param middleware: The middleware to use globally for the server
 * @param routes: The root routes for the server
 */
export let serveWithMiddleware = (middleware, routes) => {
  let wagiEnv = getWagiEnv()

  let rootRoute = scopeWithMiddleware("/", middleware, routes)
  let (reqHandler, params) = findReqHandler(getReqMethod(wagiEnv), getPath(wagiEnv), rootRoute)
  let request = {
    _message: {
      _wagiEnv: wagiEnv,
      _params: params,
      _query: getQueryMap()
    },
    _variables: Map.make(),
    _headers: getHeaders(wagiEnv),
    _body: getBody(wagiEnv)
  }
  let response = reqHandler(request)
  outputResponse(response)
}

/**
 * Entry point for creating a server, taking a list of route handlers.
 * 
 * @param routes: The root routes for the server
 */
export let serve = routes => {
  serveWithMiddleware(identity, routes)
}
